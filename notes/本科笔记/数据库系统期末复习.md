# 数据库系统期末复习

## 1. 概论

### 1.1 课程绪论

1. Database System Applications 数据库系统应用

   * DBMS(Database Management System) 数据库管理系统适用于管理大量数据并支持并发访问的系统，它包含着大量的数据、访问这些数据所需要的程序已经优化使用的环境
   * Database Applications Examples 数据库应用的例子有很多，数据库在我们生活的方方面面

2. Purpose of Database Systems 

   * 在没有数据库系统之前，我们采用文件系统的方式来管理数据，可是文件系统存在种种问题：
     * Data redundancy and inconsistency （ 数据冗余与不一致 ）
     * Difficulty in accessing data （ 存取数据困 难）
     * Data isolation （ 数据孤立，数据孤 岛）
     * Integrity problems（ 完整性 问题）
     * Atomicity of updates （ 原子性 问题）
     * Concurrent access by multiple users（ 并 发访问 异常 ）
     * Security problems（ 安全性 问题）
   * 数据库系统就是为了解决这些问题而产生的，因此相应地数据库系统有着以下特点
     * data persistence (数据持久性)
     * convenience in accessing data (数据访问便利性)
     * data integrity (数据完整性)
     * concurrency control for multiple user (多用户并发控制)
     * failure recovery (故障恢复)
     * security control (安全控制)

3. View of Data

   数据库系统有一个主要目的是要隐藏数据存储和维护细节，为了实现这个目的，数据库系统有着：

   * Data Models（数据模型）

     数据模型是一系列对数据、数据之间的联系、数据语意和数据约束的描述，主要的数据模型有：Relational model ( 关系模型 )、Entity-Relationship model (实 体 -联 系模型 )、Semi-structured data model (XML) ( 半 结 构化数据模型 )、Object-based data models ( 基于 对 象的数据模型 )等模型，其中最主流的还是关系模型。关系模型可以理解为一个个表的集合，表的列称为Attributes 属性，表的行称为Tuples 元组

   * Data abstraction （数据抽象）

     数据抽象分为三个抽象层次：

     * Physical level （物理 层 ）描述数据如何存储
     * Logical level （ 逻辑层 ） 描述存储的数据和关系
     * View level （ 视图层 ） 隐藏数据类型和部分数据信息的应用程序

     这三层抽象的一个重要目的是实现数据的独立性，也就是在某一层修改数据定义，并不影响其他层的使用，便于实现数据的迁移

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261346811.png">

   * Schemas and Instances( 模式和 实 例 )：模式可以理解为数据库的总体设计，包括逻辑模式和物理模式，实例就是某一时刻数据库中具体存储的数据，他们两个的关系可以类比于变量和值的关系

4. Database Languages 

   数据库语言包括两类：

   * Data Definition Language (DDL) 数据定义语言 用于定义数据的模式，DDL语言产生的数据存储在data dictionary （数据字典），称为元数据，包括数据模式、完整性约束和授权
   * Data Manipulation Language (DML) 数据操作语言 用于数据库的查询和更新，也被叫做query language 查询语言，它分为Procedural （ 过 程式） DML和Declarative (nonprocedural ， 陈 述式，非 过 程式 ) DML，我们常使用的是后者，因为比较简单，SQL语句就是后者的代表

5. Database Design

   数据库设计包括逻辑设计和物理设计两部分，逻辑设计是我们课程讨论的重点，它决定数据库模式，需要我们对应用的具体场景了解，以及对计算机实现方式理解，物理设计救赎数据库的物理存储

6. Database Engine 

   数据库引擎包括三部分：

   * The storage manager （ 存 储 管理 ）：存储着数据文件、数据字典（存放元数据）、索引
   * The query processor component （查询处 理 ）：DDL interpreter （DDL 解 释 器，处理DDL语言 ）、DML compiler （DML编译 器，处理DML语言 ）、Query evaluation engine（查询执 行引擎 ）
   * The transaction management component （ 事 务 管理 ）：包括Transaction manager（事务管理，实现原子性操作）、Concurrency-control manager（并发控制器）

7. Database Architecture 

   分为好几种：Centralized databases、Client-server、Parallel databases、Distributed databases稍作了解即可

8. Database Users and Administrators 

   数据库的使用者包括；naive user、application programmers、sophisticated users、database administrators（DBA）

9. History of Database Systems

## 2. 关系数据库

### 2.1 关系模型

1. Structure of Relational Databases 关系数据库结构

   上一节也已经提到，对于关系数据库中的一个关系，我们可以理解为一个表，它的列是属性，行是元组（可以理解为一个对象）。

   * Attributes 属性
     * 属性都有一个取值范围，称为domain （域）
     * 每一个属性都是atomic （原子的），也就是不可再分
     * null （空值）可以存在于每一个domain中，它表示unknown，在很多情况下，null可以会引起一些冲突，所以需要对其进行处理
   * tuple 元组
     * 一个关系中的元组相当于一个集合，也就是说元组的排序是不重要的，也不会有重复的元组

2. Database Schema 数据库模式

   几个重要概念：

   * A1 , A2 , …, A n 是attributes，则R = (A1 , A2 , …, A n ) 是一个relation schema 关系模式

   * relation instance r关系实例是定义在关系模式之上的
   * Database schema：数据库的逻辑实现，比如instructor (ID, name, dept_name, salary)
   * Database instance：数据库的快照，可以理解为具体的表

3. Keys 码

   Keys 码都是R的一个子集

   * superkey （超键）：可以唯一确定一个元组的key
   * candidate key （候选键）：最小的超键（指不可再减少，而不是属性个数最少，所以可以有多个大小不一样的候选键）
   * primary key （主键）：候选键选择其中之一
   * Foreign key （外键）：关系中的值一定出现在另一个关系中，比如Referencing是teaching，Referenced是老师，每一个teaching中的授课老师都是在老师这个关系中出现，而不是所有的老师都会上课

4. Schema Diagrams 模式图

5. Relational Query Languages 关系查询语言

   分为过程式（详细描述查询的过程）和非过程式（语言中不体现查询过程，SQL是其中的代表）

6. The Relational Algebra 关系代数

   关系代数顾名思义操作数和结果都是关系，它有六个基本操作：

   * select: $\sigma$ 选择操作

     选择操作是选择满足某种条件(selection predicate)的元组，$\sigma_p(r)$，例如选择物理系的教授：$\sigma_{dept\_name = "Physics"}(instructor)$

     对于选择的条件selection predicate，我们可以让它更复杂：

     * 支持各种比较操作
     * 支持集合运算操作；and、or、not

   * Project：$\Pi$ 映射操作

     选择操作可以理解为选择表中的行，映射操作就可以理解为选择表中的某些列，它用于选择给定的某些属性，$\Pi_{A_1, A_2,A_3...A_k}(r)$，并且选择之后会去掉重复的元组，比如删除导师关系中学院一栏，$\Pi_{ID,name,salary}(instructor)$

     将选择操作和映射操作组合起来可以发挥更大的作用，比如选择物理系教授的名字$\Pi_{name}(\sigma_{dept\_name = "Physics"}(instructor))$

   * Cartesian-Product: X 笛卡尔积

     笛卡尔积是一个二元的运算符，它将两个关系相乘，结果的属性是两个原来的关系的属性之和，它的元组是一一组合而成的结果，比如一个关系有5个元组，4个属性，另一个关系有4个元组3个属性，则他们的笛卡尔积有20个元组和7个属性，当然，笛卡尔积的结果似乎并没有太大价值，但是和别的操作进行组合后可以发挥很重要的作用

   * Join ⋈ 连接操作

     连接操作本质上是对两个关系的笛卡尔积进行了一步选择操作 𝑟 ⋈ 𝜃 𝑠 = 𝜎 𝜃 ( 𝑟 × 𝑠 )，比如选择老师和它教的课连接起来：我们可以$\sigma_{instructor.id=teachers.id}(instructor\ X\ teachers)$,如果用连接操作的话就是$instructor ⋈ _{Instructor.id = teaches.id} teaches$

   * Union $\cup$ 组合操作

     组合操作类似于集合的并集，$r\cup s$，我们将两个集合的元组合并后去重，不过要合并的两个关系需要满足：

     * 两个关系的arity (元数，属性数量）相同
     * 两个关系的每一个属性对应的domain一致

     比如我们要选择2017年秋开课或者2018春开课的课程号：$\Pi_{course_id}(\sigma_{semester="Fall"\wedge year=2017(section)}\cup \sigma_{semester="Spring"\wedge year=2018(section)})$

   * Set-Intersection $\cap$ 交集操作

     组合操作类似于集合的交集，$r\cup s$，我们选择同时出现在两个关系的元组，不过要合并的两个关系需要满足：

     * 两个关系的arity (元数，属性数量）相同
     * 两个关系的每一个属性对应的domain一致

     比如我们要选择2017年秋开课且在2018春开课的课程号：

     $\Pi_{course_id}(\sigma_{semester="Fall"\wedge year=2017(section)}\cap \sigma_{semester="Spring"\wedge year=2018(section)})$

   * Set Difference - 集合差操作

     集合求差，使用方法和之前两种类似

   * Assignment $\leftarrow$ 赋值操作

     赋值操作可以对关系代数中间产生的关系命名，主要作用是使语句更加清晰，便于理解，类似于程序设计语言

     比如我们要查找物理系和音乐系的老师：
     $$
     Physics \leftarrow \sigma _{dept_name=“Physics”} (instructor) \\
     Music \leftarrow \sigma _{ dept_name=“Music”} (instructor) \\
     Physics \cup Music
     $$

   * Rename $\rho$ 重命名

     在关系代数产生的关系中，它的属性并没有被命名，可以用重命名操作给它命名

     $\rho_{x(A1,A2,...An)(E)}$

   对于一个查询，我们往往有不止一种查询方式，我们要选择最好的查询方法，一个很重要的原则就是笛卡尔积的计算放在最后

### 2.2 SQL初步

1. Overview of The SQL Query Language SQL查询语言概述

2. SQL Data Definition 数据定义

   DDL 数据库定义语言定义关系的种种信息：

   * 每一种关系的模式
   * 每一个属性的类型
   * 完整性约束
   * 索引
   * 每一个关系的安全和授权
   * 每一个关系的物理存储

   SQL中数据的类型：char(n), varchar(n), int, smallint, numeric(p, d), real, double precision, float(n)

   定义关系语句结构：

   ```sql
   create table r(
     A1 D1,A2, D2,...An Dn
     intergrity-constraint1...)
   ```

   其中r是关系的名字，每一个A1是一个属性的名字，D是属性的类型，完整性约束有三种：

   * primary key (A1, ..., A n) 主键默认非空
   * foreign key (Am, ..., A n) references r
   * not null

   具体例子：

   ```sql
   create table instructor (
     ID char(5), 
     name varchar(20) not null, 
     dept_name varchar(20), 
     salary numeric(8,2), 
     primary key (ID), 
     foreign key (dept_name) references department);
   ```

   关系的更新：

   * insert 插入元组`insert into instructor values ('10211', 'Smith', 'Biology', 66000);`
   * Delete 删除元组`delete from student`(删除关系中所有元组)
   * Drop Table 删除关系 `drop table r`（不止删除内容，关系模式也被删除）
   * Alter 更改关系模式
     * `alter table r add A D` 增加一个属性，对于之前的元组，该属性默认为NULL
     * `alter table r drop A` 删除一个属性

3. Basic Query Structure of SQL Queries 基础查询结构

   基本的查询结构

   ```sql
   select A1, A2,...An
   from r1, r2, ...rm
   where P
   ```

   A代表查询结果的属性，R表示要查询的关系，P是查询条件，注意SQL是对大小写不敏感的

   * select语句：类似于关系代数中的project 映射操作
     * 查询的结果可能有重复，如果要去除重复，需要用distinct关键字`select distinct dept_name`
     * 如果要查询所有属性，则需要*`select *`
     * select语句中，对于属性可以有一些加减乘除或常数算术运算操作`select ID, name, salary/12`
   * where 语句：类似于关系代数中的selection predicate 选择的条件
     * 在where语句中，和关系代数类似，可以用比较操作符和与或非等逻辑操作符`where dept_name = 'Comp. Sci.' and salary > 70000`
   * from 语句：类似关系代数中 的笛卡尔积
     * 直接使用得到的是笛卡尔积，并没有太大的意义，但是和where语句合用就能有重要作用

4. Additional Basic Operations 基本操作

   * Rename 重命名操作

     * 可以重命名任何一个属性或者关系`old-name as new-name`

     * 有些情况下重命名操作能发挥重要作用，比如选择工资不是最低的教授的姓名

       ```sql
       select distinct T.name 
       from instructor as T, instructor as S  # from语句中的重命名操作可以省略as
       where T.salary > S.salary and S.dept_name = 'Comp. Sci.’
       ```

   * Self Join 自连接操作——以后会详细介绍

   * String 字符串操作

     * whree设置条件时可以用like关键字查找符合某一类型的字符串`where name like '%dar%'`
     * 有两个常用的转义符：%代表一个字符串，_表示一个字符

   * order by 排序操作

     * 可以将查询结果排序，有desc 降序和asc升序两种排序方法，默认为升序排列`order by name desc`

5. Set Operations 集合操作

   基本类似于上一节的关系代数，并集：union、交集：interact、差集：except

   ```sql
   (select course_id from section where sem = 'Fall' and year = 2017) 
   union / intersect / except
   (select course_id from section where sem = 'Spring' and year = 2018)
   ```

   集合操作默认会去重，如果想要显示重复元组，则在相应的关键词后面添加all即可

6. Null Values 空值

   空值有两种含义：一是不知道unknown，二是不存在 not exist(有null和not null两种形式)

   * 任何包含null的算术运算结果都是null `5 + null returns null`

   * null也可以用于where语句的查询 `where salary is null`

   * 逻辑表达式中null的意义往往是unknown，它的逻辑计算也比较特殊：

     ```sql
     and : 
     (true and unknown) = unknown,
     (false and unknown) = false, 
     (unknown and unknown) = unknown
     or:
     (unknown or true) = true,
     (unknown or false) = unknown 
     (unknown or unknown) = unknown
     ```

7. Aggregate Functions 聚合函数

   聚合函数对于某个多重集的一列进行运算，返回一个值，常见的有：avg、min、max、sum、count

   * group by 分组操作

     对一个关系中的元组进行分组操作，注意如果有分组操作，select中的属性一定要出现在group by的关键字中

     ```sql
     select dept_name, avg (salary) as avg_salary
     from instructor
     group by dept_name;
     ```

   * Having 

     * 对于分组后的数据进行一些限制，注意where语句用于分组之前，having语句用于分组之后

     ```sql
     select dept_name, avg (salary) as avg_salary 
     from instructor 
     group by dept_name 
     having avg (salary) > 42000;
     ```

8. Nested Subqueries 嵌套查询

     由于SQL语句查询的结果是一个关系，所以任何需要一个关系的地方我们都可以用子查询来替代，对于from语句，r可以被任意一个子查询替代；对于select语句，A可以被任何一个仅返回一个值的子查询替代；对于where语句，子查询的形式比较复杂，P可以被一个类似B \<operation\> (subquery)的形式替代

   有关where的嵌套查询——B \<operation\> (subquery)的几种类型：

   * Set Membership 关系从属，这里的operation就是in / not in
   * Set Comparison 集合比较，这里的operation可以是任意一个比较运算符+some/all关键词
   * exists：这里B省略，operation为exists或者not exists，对应子查询的结果是否为空
   * unique：这里B省略，operation为uniques，对应子查询的结果是否有重复元组

   有关from的嵌套查询

   * 由于from语句需要的就是一个关系，所以from语句的内容可以被任意子查询代替

   * with语句可以用来使查询语句更加简洁明了

     ```sql
     with max_budget (value) as
     	(select max(budget) 
      	from department) 
     select department.name 
     from department, max_budget 
     where department.budget = max_budget.value;
     ```

   有关select的嵌套查询——Scalar Subquery 标量子查询

   * 标量子查询就是查询结果只有一个值的子查询

     ```sql
     select dept_name,
     	( select count(*)
        from instructor
        where department.dept_name = instructor.dept_name)
        as num_instructors 
     from department;
     ```

9. Modification of the Database

   > 在数据库修改语句中，如果出现select语句，由于数据库修改操作可能会改变select查询到结果，因此是先做查询，然后在统一做修改

   * Deletion 删除操作 `delete from instructor`后面可以增加where语句，可以理解为先用select查询出来，再将结果删除，所以select语句的用法都可以移植到delete操作中

   * Insertion 插入操作 `insert into course values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);，`插入操作的内容也可以是select语句的结果，必须保证查询对应选择的属性和被插入的关系的属性一致

   * Updates 更新操作 `update instructor set salary = salary * 1.05`，对于分情况地更新操作，可以使用case关键字

     ```sql
     update instructor
     	set salary = case
     		when salary <= 100000 then salary * 1.05
     		else salary * 1.03
     		end
     ```

### 2.3 中级SQL

1. Join Expressions 连接操作

   连接操作可以理解为对笛卡尔积设定一定的约束条件，连接类型有三种：

   * natural join 自然连接
     * 自然连接是将两个关系中相同属性的值相等的元组进行连接，连接的结果中属性只保留一份（这是与其他连接方式非常重要的区别）`select name, course_id from student natural join takes;`
     * 自然连接也可以多个并列使用
     * 但是自然连接可能会遇到一些问题，比如当两个关系中有多个相同属性，而我们并不关心其中一部分属性的值是否相等，如果用自然连接可能会出现问题，此时可以用之前的where语句约束相等或者using关键词选择特定的属性`from (student natural join takes) join course using (course_id)`
     * 对于连接操作，有时候会用on关键词进行条件约束，不过在自然连接中，on和where是等价的，它们的主要区别在于外连接

   * Outer Join 外连接
     * 自然连接将两个关系中不能匹配的元组直接丢弃，有时候我们不想这么做，可以使用外连接，外连接分为左外连接、右外连接、全外连接，分别保留关系A中不匹配元组、关系B中不匹配元组、关系A和B中不匹配元组，将这些不匹配的元组放在最终结果关系的元组中，那些原关系没有的属性对应的值设置为null
     * 对于外连接，on语句`course left outer join prereq on course.course_id = prereq.course_id`结果是外连接结果，where语句则是对外连接结果进一步条件选择，最终结果类似于自然连接 
     * 如果是自然外连接，则最大区别就是重复的属性类型被省略为1个，用using关键词也会达到类似的结果，只是natural相当于using（所有重复的属性）
   * inner join 内连接 默认的join操作就是内连接，相当于求笛卡尔积

2. Views 视图

   *  视图是一个virtual relation 虚拟的关系，它通常并不是一个物理存在的实体，而是一个查询结果
   * 视图的定义方式为`create view v as < query expression >`，定义视图后我们就可以像使用一个关系那样使用视图，不过在底层实现层面，其实就是把view替换成它对应的查询
   * 视图可以定义在其他视图之上，如果视图v2用了视图v1中的定义，则我们称v1 depend directly v2，称v2 depend on v1，有时候视图也会递归地定义
   *  View Expansion 视图扩展就是在实际使用视图的时候本质上是将视图替换为它所对应的查询
   * Materialized Views 物化视图 是将视图物理层面上进行存储（类似于建立一个新的关系？），是一种空间换时间的策略，不过更新是个问题
   * 视图的更新：视图更新可能会引发一系列问题，因此大部分SQL语言只支持非常简单的视图更新

3. Index Definition in SQL 索引定义

   * 索引是对关系的某一个属性建立一个数据结构，便于高效地实现查询操作 `create index studentID_index on student(ID)`

4. Transactions 事务

   * 事务就是作为整体的一系列任务的集合，在SQL语句中，一个事物必须以最终两种方式结束：commit work和Rollback work

5. Integrity Constraints 完整性约束

   * Not Null 非空约束 `name varchar(20) not null`

   * Unique 唯一性约束 `unique`

   * check语句：check语句用于对关系的某一个属性的取值范围机械能约束，限定在一个关系范围内，这个关系可以用一个查询语句表示 `check (time_slot_id in (select time_slot_id from time_slot))`

   * Referential Integrity 关联完整性，一般就是指foreign key 外码 ，默认情况下，外码所指的属性是所指关系的主码，`foreign key (dept_name) references department (dept_name)`，外码这种完整性约束会涉及两个关系，当完整性约束不满足时，这就需要级联操作（操作一个关系，为了满足完整性约束，需要对与它有reference的关系也进行相应的操作），一般有四种：on delete cascade级联删除、on update cascade级联更新、set null设为空值、on update cascade设为默认值

   * Assertions 断言：check是对于一个属性的约束条件，断言则是对于一个关系的约束条件`create assertion <assertion-name> check (<predicate>);`

   * Triggers 触发器：触发器是一种非常强大的约束操作，它遵循ECA规则，E是event、C是condition、A时action，event主要是数据库的插入、更新、删除操作，在condition中常用到元组的两个值，之前的referencing old row as，之后的referencing new row as

     ```sql
     create trigger setnull_trigger before update of takes 
     referencing new row as nrow 
     for each row
     	when (nrow.grade = ' ')
     	begin atomic
     		set nrow.grade = null;
     end;
     ```

     触发器功能很强大，但是由于触发触发器之后的一系列操作是自动进行的，常常会产生出乎数据库管理者的结果，一般情况下最好不要用触发器

6. SQL Data Types and Schemas 数据类型和模式

   数据类型我们之前已经介绍了很多，现在再补充一些：

   * date 日期 '2005-7-27'
   * time 时间 '09:00:30'
   * timestamp 时间戳 '2005-7-27 09:00:30.75'
   * interval  时间间隔 '1' day
   * 大数据：blob: binary large object（如图片、视频）、clob: character large object（如电子书），对于大数据的查询中，外码通常使用pointer而不是查询大数据本身
   * 用户也可以自定义数据类型 `create type Dollars as numeric (12,2) final`，用户还可以自定义数据范围，`create domain person_name char(20) not null`和定义数据类型的主要区别在于数据domain可以设置约束条件

7. Authorization 权限管理

   对于一个relation，它有read、insert、update、delete四个递增的条件，对于一个数据库模式，它有index建立索引、resourece建立关系、alteration修改关系模式、drop 删除关系模式等权限

   SQL语句中的授权语句：

   ```sql
   grant <privilege list> // privilege: 权限 
   on <relation or view > to <user list>
   ```

   这里的user list可以是用户名，也可以是public（指全体用户）和一个role 身份，SQL语句中privilege list包括：select、insert、update、delete和all privilege

   授予权限之后还可以用revoke语句回收权利 `revoke <privilege list> on <relation or view> from <user list> Example:`注意此时的privilege list 包括要求收回权利者的所有权利，如果一个用户被多个人授予某一权利，则某人revoke之后并不能让它失去权利

   Roles 身份管理 role用于同时拥有一系列权利的用户集合，使用方法为

   ```sql
   create role instructor;
   grant instructor to Amit;
   grant select on takes to instructor;
   ```

   role可以被授予给一个用户，也可以授予一个role，比如将教师的role授予系主任的role

   有关view的授权：对于一个view拥有某项权利，只有当同时拥有view对应的关系的相应条件时，才是真正拥有该权利

   References （引用） privilege 引用权利也可以被授予，只有某个用户拥有引用权利时，它建立关系模式时才能将foreign key reference到相应的关系上

   权限的级联操作：

   * `grant select on department to Amit with grant option;` 授予权限的同时授予了将权限授予出去的权限
   * `revoke select on department from Amit, Satoshi cascade;`收回权限并收回该用户所授予的权限
   * `revoke select on department from Amit, Satoshi restrict;` 如果该用户将权限授予出去，则终止收回权限的操作



### 2.4 高级SQL

1. Accessing SQL From a Programming Language 通过程序语言访问SQL

   SQL语言是一种不完备的过程式语言，是非图灵机等价的语言，也就是说SQL不完完成所有操作，有些操作必须借助高级程序语言来实现，但是将SQL语言和高级程序语言连接起来需要解决两个主要问题：两者数据类型不匹配、操作的对象也不匹配（一个是关系，一个是value）

   通过程序语言访问SQL的方法有两种，一个是 Dynamic SQL 动态SQL语句，即调用一系列API来使用SQL语句，另一种是Embedded SQL 嵌入式的SQL语句，将SQL语句直接嵌入到高级程序语言中，编译时会由编译器识别哪些是SQL语句，哪些是高级程序语言的语句

   动态SQL语句常用的有两类，一个是ODBC，专门用于C系列的语言（C++, C#, and Visual Basic），JDBC是用于Java的语言

2. Functions and Procedures 函数和过程

   上一节提到trigger时不建议使用，可以用函数或者过程来代替，定义和使用一个函数的例子：

   ```sql
   create function dept_count (dept_name varchar(20)) 
   		returns integer  // 定义返回类型
     begin 
     declare d_count integer; 
     	select count (* ) into d_count 
     	from instructor 
     	where instructor.dept_name = dept_name 
     return d_count;
   end
   
   
   select dept_name, budget 
   from department 
   where dept_count (dept_name ) > 12
   ```

   有时候还可以定义Table Functions 表函数，也就是函数的返回是一个表，它的定义和使用与其余的函数也不像

   ```sql
   create function instructor_of (dept_name char(20))
   returns table ( 
     ID varchar(5), 
     name varchar(20), 
     dept_name varchar(20), 
     salary numeric(8,2))
   return table 
   	(select ID, name, dept_name, salary 
      from instructor 
      where instructor.dept_name = instructor_of.dept_name)
      
   select *
   from table (instructor_of ('Music'))
   ```



## 3. 数据库设计

### 3.1 ER模型

1. Overview of the Design Process 设计过程概述

   设计一个数据库软件有三个阶段：需求分析、选择数据模式、在逻辑和物理层面实现

   设计过程中两个主要问题：Redundancy数据冗余 Incompleteness 数据不一致

2. The Entity-Relationship Model ER模型

   ER模型是一种形象化表示数据模式的模型，可以用ER图表示，主要包括entity sets 实体集、relationship sets 关系集、attributes 属性这几个基本概念

   * entity sets 实体集

     实体就是一个不同于其他的对象，实体集则是拥有某些共同特征的实体的集合，比如一个老师是一个实体，但老师这个概念则是实体集，与关系模式相对应，实体集也有若干属性组成，其中有一个属性为primary key，在ER图中实体集的表示如下：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261346280.png" alt="截屏2022-06-09 下午1.59.00" style="zoom:75%;" />

   * Relationship Sets 关系集 

     多个实体之间的关联称为关系，关系集则是关系的集合，ER图中如下表示：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261346839.png" alt="截屏2022-06-09 下午2.01.05" style="zoom:67%;" />

     当然，有的关系集中也有属性，带有属性的关系集画法如下：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261346997.png" alt="截屏2022-06-09 下午2.01.46" style="zoom:67%;" />

     Roles 身份，其实任何一个关系的两端都有各自的身份，但通常如果不是同一个实体集，则这个身份并不需要给出，然而有一些关系连接的两个实体都是属于同一个实体集，比如课程和它的先修课，则必须明确给出它们的身份

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261346894.png" alt="截屏2022-06-09 下午2.03.51" style="zoom:67%;" />

     Degree（度）of a Relationship Set 关系集的度，大多数情况下一个关系连接两个实体集，称为Binary relationship （二元联系），但实际上关系可以是多元的，比如下图就是一个三元关系的展示：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261346629.png" alt="截屏2022-06-09 下午2.05.49" style="zoom:67%;" />

   

3. Complex Attributes 复杂属性

   在关系模式中，我们已经讲到过，一个属性必须是原子的，但是在实际生活中，很多关系并非都是如此，因此ER模型的属性有多种类型：

   * Simple （ 简单 ） and composite (复合) attributes.：复合关系是指一个关系由多个子关系组成，比如姓名由姓+名组成，在图中用缩进表示
   * Single-valued （ 单值 ） and multivalued （多 值 ） attributes：多值关系是指一个实体的这个属性可能有不止一个值，比如一个人的电话号码可能有多个，在图中用{ }表示
   * Derived （派生） attributes：派生关系是指一个属性可以通过另一个属性计算得来，在图中用()表示

   当然ER模型中的属性也都有各自的domain

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347398.png" alt="截屏2022-06-09 下午2.10.56" style="zoom:67%;" />

4. Mapping Cardinalities 映射基数约束

   映射基数约束直观理解就是一个关系连接的两类实体各自最多有多少个，对于一个二元联系集，映射基数有以下四种：One to one一对一、One to many一对多、Many to one多对一、Many to many多对多，注意这种约束是at most的，也就是多最多达到这个数量，实体集中的一些实体不与另一实体集的实体建立关系也是可以的，它们在ER图中有两种形式：箭头表示一、线段表示多，比如一个导师可以指导多个学生，一个学生最多有一个导师的表示图：

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347664.png" alt="截屏2022-06-09 下午2.16.22" style="zoom:67%;" />

   Total and Partial Participation 全部参与和部分参与：也很好理解，全部参与就是一个实体集中的全部实体都参与该关系，ER图中用双横线表示

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347746.png" alt="截屏2022-06-09 下午2.45.35" style="zoom:67%;" />

   映射基数的另一种表示方法：左边表示最少，右边表示最多，*表示不限制

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347827.png" alt="截屏2022-06-09 下午2.46.37" style="zoom:67%;" />

5. Primary Key 主码

   对于主码的叙述我们将从三类集合中展开：Entity sets实体集、Relationship sets关系集、Weak entity sets弱实体集

   * Entity sets实体集：实体集中的主码和我们之前在关系模式那部分叙述一样

   * Relationship sets关系集：关系集的属性由两部分组成，一部分是关系涉及的实体集的属性，另一部分是关系集自身的属性，简单表示的话关系集的属性可以是关系集所关联的两个实体集的主码的并集，不过实际上关系集的主码和映射基数的约束有关

     * Many-to-Many 两个实体集的主码的并集
     * One-to-Many/Many-to-one the “Many” side的主码
     * One-to-one 任何一个实体集的主码

   * Weak Entity Sets 弱实体集

     * 弱实体集可以理解为其他实体集的附属，它没有完整的主码（由于减少冗余，它的主码的一部分被省略，它原有主码的剩余部分被叫做discriminator （ 分辨符 , or partial key），它相关联的联系叫做identifying relationship （ 标识 性 联 系）

       <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347320.png" alt="截屏2022-06-09 下午2.55.58" style="zoom:67%;" />

     * 对于弱实体集，它的主码由它的部分码和它相联的实体集的主码组成

6. Removing Redundant Attributes in Entity Sets 去除实体集的冗余属性

   对于不同实体集所拥有的相同属性，为了避免冗余，应该将其去掉

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347469.png" alt="截屏2022-06-09 下午3.01.43" style="zoom:67%;" />

7. Reducing ER Diagrams to Relational Schemas ER图转化为关系模式

   其实就是把ER图转化为前几章学习过的关系模式（表）

   * 表示实体集：很直观，不需赘述；表示弱实体集：将原本省略的属性补充后即可。如果实体集中有一些Composite Attributes 复杂属性，如果是composite (复合) attributes.，只在关系模式中列入子属性，如果是Derived （派生） attributes，可以直接省略，如果是multivalued （多 值 ） attributes，则可以用主键和该属性为属性建立一个新的模式
   * 表示关系：对于一个多对多的关系，必须转化为一个relation，它的主键我们之前已经介绍过；对于一个其他映射基数约束的关系，它可以不转换为relation，而是将主键所在的部分添加一个属性（关系相连的另一个实体集的主键）

8. Extended E-R Features

   * Specialization（特化）特化是一种自顶向下的设计模式，与程序设计中的继承类似，比如一个实体集是person，则它可以特化出两个实体集student和instructor，它们不仅有person的属性，还有各自特殊的属性。特化分为Overlapping （重叠特化）和Disjoint 不相交特化 ），重叠特化是指高层次的实体集可以属于多个低层次的实体集，比如一个人可以既是学生又是雇员，不相交特化是指一个高层次的实体集属于低层次实体集之一，不能同时is a，当然，特化也有Total and partial的概念

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347158.png" alt="截屏2022-06-09 下午5.00.09" style="zoom:67%;" />

     特化转化为关系模式的方式有两种：一是在低层次实体集中包含高层次实体集的属性，另一种不包含，用主键相关联，各有各的好处

   * Generalization（概化）：概化和特化相反，是自底向上的，不过概化和特化本质上都是一个东西，只是角度不同

   * Aggregation 聚合：类似于程序设计中的封装，我们将多个实体集和关系集看成一个虚拟的实体集，与其他实体键建立联系

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347710.png" alt="截屏2022-06-09 下午5.04.12" style="zoom:67%;" />

9. Entity-Relationship Design Issues

   * 属性的冗余
   * 关系的属性要特别注意
   * 设计时选择关系集还是实体集
   * 二元关系还是多元关系

10. Alternative Notations for Modeling Data

11. Other Aspects of Database Design

### 3.2 规范化

1. Features of Good Relational Design 好的关系设计特点

   一个bad的关系往往有两个问题：信息重复和更新困难（有时候需要null）

   因此我们需要将一个关系模式分解成为两个关系，在这个分解过程中我们需要保证分解后的结果能够通过自然连接恰好得到分解之前的关系模式，如果不能，则称为这个分解是A Lossy Decomposition 有损分解（分解之前的关系是分解后的两个关系自然连接得到的结果的子集），如果可以，则称为Lossless Decomposition 无损连接

   Normalization Theory 规范化理论就是判定一个关系是否是一个good的形式，对于一个bad的关系，我们要想一种无损分解，将它分解成若干个good的关系，规范化理论基于两点：Functional dependencies 函数依赖、Multivalued dependencies多值依赖

2. Decomposition using Functional Dependencies 基于函数依赖的分解

   函数依赖其实就是对数据的一系列限制，我们之前常说的主码就是一种特殊的函数依赖，符合函数依赖的实例称为legal instance合法实例。如果用数学语言表示的话，函数依赖可以写作：

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347302.png" alt="截屏2022-06-09 下午7.52.35" style="zoom:67%;" />

   即对于相同的a，b的值也一定相同，比如一个地方的地址唯一确定它的邮编

   * key和函数依赖

     函数依赖其实就是key的一个泛化表示，主码、候选码这些都可以用函数依赖表示：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347962.png" alt="截屏2022-06-09 下午7.54.47" style="zoom:67%;" />

   * 函数依赖的用途：一是可以检验一个关系是否满足函数依赖；也可以根据关系的合法实例找到其函数依赖

   * Trivial Functional Dependencies 平凡函数依赖是指一个属性集合可以确定这个属性集合的任意一个子集（也就是自己确定自己）

   * Closure of a Set of Functional Dependencies 函数依赖的闭包 一个关系的所有依赖组成的集合（所有依赖可以根据现有的依赖推理得到）

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347154.png" alt="截屏2022-06-09 下午7.58.27" style="zoom:67%;" />

   * Lossless Decomposition 无损分解可以用函数依赖的方式表示，如果一个关系的分解后的两个关系的交集可以是其中任意一个子关系的super key，则这个分解是无损的

   * Dependency Preservation 依赖保持是说对于原来关系的函数依赖，如果可以在分解后的关系中直接验证，则这种分解称为依赖保持的，如果只能在分解后的关系再做笛卡尔积得到的关系上验证，则这种分解不是依赖保持的

3. Normal Forms 范式

   * Boyce-Codd Normal Form BC范式的定义是说对于一个关系的闭包中的所有函数依赖，它要么是一种平凡的函数依赖，要么是R的一个super key，将一个关系模式分解成为BC范式的方式是：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347369.png" alt="截屏2022-06-09 下午8.33.53" style="zoom:67%;" />

     BC范式可以保证无损分解，但是不能保证依赖保持

   * Third Normal Form 3NF相比BC范式，约束条件稍微放松了一点，于一个关系的闭包中的所有函数依赖，它要么是一种平凡的函数依赖，要么是R的一个super key，要么Each attribute A in b – a is contained in a candidate key for R.（each attribute may be in a different candidate key)，根据3NF的定义可知，一个关系是BCNF则一定是3NF，如果一个关系是3NF则不一定是BCNF

   * Comparison of BCNF and 3NF

     * 3NF可以保证同时满足无损分解和依赖保持；BC范式可以保证无损分解，但是不能保证依赖保持
     * 3NF可能会有一些信息冗余和更新困难的问题，BCNF则不会有

   * 规范化的目标：

     * 分解后的每一个关系模式都是good的
     * 无损分解
     * 尽可能依赖保持

4. Functional Dependency Theory 函数分解理论

   * closure 闭包

     计算闭包常用的几个公式：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347189.png" alt="截屏2022-06-09 下午8.44.05" style="zoom:67%;" />

     二级公式：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347816.png" alt="截屏2022-06-09 下午8.44.33" style="zoom:67%;" />

     属性的闭包，属性的闭包就是该属性集所能确定的属性组成的集合，计算算法如下

     ```java
     // Algorithm to compute a^+
     result := a
     while(change to result) do
       	for each b->r in F do
           	begin 
           		if B is in result then result := result + r
               end
     ```

     属性闭包的作用：

     * 在BCNF中检验一个key是否是super key

     * 再正则覆盖中选择无关属性

     * 计算F的闭包：

       计算方法是计算R所有子集的属性闭包，然后将结果合并起来

   * Canonical Cover（正则覆盖）

     正则覆盖说的是对于F我们要找其中一个最小的函数依赖集合使得闭包与之前F的闭包相同，要想计算正则覆盖，首先要知道Extraneous Attributes (无关属性)

     对于一个函数约束，如果我们将a侧或b侧的一个属性去掉，并不影响最后F的闭包，则这个属性称为无关属性，用数学方法表示它的定义如下：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347763.png" alt="截屏2022-06-09 下午9.09.18" style="zoom:67%;" />

     检验一个属性是否是无关属性的方法：

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261347298.png" alt="截屏2022-06-09 下午9.11.02" style="zoom:67%;" />

     正则覆盖的规范定义：首先F和Fc的闭包相等；Fc中没有一个函数依赖有无关属性；Fc左侧相等的函数依赖都被合并

     计算正则覆盖的算法：

     * 用union rulr将a侧相同的函数约束合并

     * 找到一个无关属性并去掉
     * 重复该操作直到F不再变化

     Dependency Preservation 依赖保持，检验分解后的一个函数依赖（a -> b) 是否被保持的算法：

     ```c++
     result = a
     对于每一个分解后的关系R，检验reslut在该关系中的属性函数依赖
     将结果添加到result集合中
     重复该操作直到result对于每一个分解后的关系都不再改变
     ```

     检验依赖保持需要我们检验F中所有的函数依赖是否被保持

5. Algorithms for Decomposition using Functional Dependencies 用函数依赖的分解算法

   * 检验一个关系是否为BCNF

     算法思想：直观地想，可以根据定义，检验一个关系的函数依赖闭包中所有关系是否满足BCNF的两个要求（要么平凡，要么a是一个super key），一种简单的算法是直接检验F中的函数依赖是否满足BCNF的两个定义，但是这种方法不适用于检验一个关系分解后的关系是否还满足BCNF

     对于分解后的关系是否满足BCNF，我们有如下算法：
     对于分解后的Ri的每一个子集，我们检查它的属性闭包是否满足：要么包含Ri的所有属性，要么只包含它自己，如果所有Ri的每一个子集都满足的话，我们称分解后的关系是BCNF的，也就是该分解是无损分解

   * BCNF 分解算法

     其实之前在范式那一节中已经做了介绍，其思想就是将不满足定义的函数依赖 a -> b找出来，然后将a, b分解成一个单独的关系，将R - b分解为另一个单独的关系

   * 3NF的检验：也是根据其定义，对于一个关系的函数依赖闭包，我们需要检验它是否满足3NF的三个定义

   * 3NF的分解算法

     ```c++
     将F转化为它的正则依赖Fc
     对于Fc中的每一个函数依赖，如果没有R同时包含a，b的所有属性，则分解出一个新的R包含a，b的所有属性
     最终如果没有一个R包含原关系的候选码，则仔分解出一个新的R，它包含全部的候选码
     最后一步做一个去重工作，如果有一个R的全部属性包含在另一个R中，则删掉属性较少的R
     ```

   * 设计目标：

     * BCNF、无损连接、依赖保持
     * 退而求其次：缺少依赖保持、3NF

6. Multivalued Dependencies 多值依赖

   多值依赖MVD 说的其实就是在一个关系中，尽管所有属性都是被候选码唯一确定的，但是其余属性之间互不关联，这时即使达到BCNF，但仍然可能会产生信息冗余等情况

   4NF就是在多值依赖的基础上提出的

7. Additional Issues



## 4. 数据存储于查询

### 4.1 物理存储系统

这一章内容其实主要在计算机组成一课中有所介绍

1. Classification of Physical Storage Media 物理存储介质的分类

   * volatile storage 易失性、non-volatile storage 非易失性
   * 影响物理存储介质选择的因素：Speed、Cost、Reliability

2. Storage Hierarchy 存储级别

   <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261348226.png" alt="截屏2022-06-10 上午10.56.57" style="zoom:80%;" />

3. Magnetic Hard Disk Mechanism 磁盘的原理

   几个概念：

   * Read-write head 读写头
   * tracks （磁道）
   * sectors ( 扇区 )
   * Disk controller （磁 盘 控制器）

   磁盘性能的测量：

   * Access time （ 访问时间 ）：Seek time (寻道时间) + Rotational latency ( 旋 转 等待 时间)
   * Data-transfer rate （数据 传输 率）：根据访问时间计算
   * Mean time to failure (MTTF, 平均故障 时间)：衡量磁盘可靠性的指标
   * Disk block：磁盘存取的基本单位，一般是几个扇区
   * Sequential access pattern 顺序访问 / Random access pattern 随机访问
   * I/O operations per second (IOPS) 每秒IO操作数，磁盘运行效率的指标

   优化磁盘访问的方法：

   * Buffering 内存中开辟一段缓冲区，利用数据的局部性，减少IO次数
   * Read-ahead: 预先读，也是依赖数据局部性的，减少IO次数
   * Disk-arm-scheduling 磁盘臂按照一定顺序访问，而不是跑来跑去（类比于电梯，并非先到先服务），降低寻道时间
   * File organization 文件组织 去碎片化
   * Non-volatile write buffers 非易失性写缓存 把文件暂时存放在Nvw中（内部有电源，不会丢失数据）
   * Effective query processing algorithms (high-level optimization)

### 4.2 数据存储结构

1. File Organization 文件组织

   一个数据库本质上就是一系列的文件，每一个表都存放一个文件中。

   * Fixed-Length Records 定长记录

     定长记录是说一个文件中只存储一个表，而且表中的所有属性都是定长的，不允许一个元组存储在不同块中，对于一个定长记录的文件来说，在表中定位一个元组或者是在元组中定义一个属性都是很简单的，对于处理数据的删除问题，有三种常用的方式：

     * 第一种是将删除元组后面的元组都向前移动一位
     * 第二种是将最后一个元组移动到被删除元组的位置
     * 第三种是建立一个free list，它指向所有被删除的元组的位置

   * Variable-Length Records 变长记录

     如果一个文件中存储多个表，或者一个表中有一些属性是变长的，或者有一些属性是有多值的（一个人有多个电话），存储方法稍微复杂一些

     * 在一个元组中定位一个属性值的方法：

       元组中的属性仍然是按顺序存放的，不过对于那些变长的数据，我们将原来具体数据内容替换成一个固定长度的空间（偏移量 + 长度），将数据具体内容存放在后面，那些定长数据还是存放在原位置，最终还有一个null-value bitmap （空位 图 ），它的每一位表示一个属性是否为空，如果为空，则该位置上存储的数据失效。这样一来，在元组中定义它的属性值是容易的，只是需要两步查找即可，不过每一个元组的长度仍然不是固定的

       <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261348909.png" alt="截屏2022-06-10 上午11.41.17" style="zoom:67%;" />

     * 在一个表中定位一个元组的方法（Slotted Page Structure 分槽页结构）：

       我们将一个表分为三部分：block header、free space、records

       其中block head内部首先由个head，它记录一共有多少个记录以及free space的最后位置，block head其余部分由所指向元组的size和location两部分组成，这种存储方法的好处在于使数据具有一定的独立性，数据之间也都没有empty space

2. Organization of Records in Files 文件中记录的组织

   对于一个表中的多个元组，它们的排序方式有多种选择：

   * Heap file organization 堆文件组织

     堆文件组织的特点是没有次序的存储，只要block中有空间就将数据存入，对这种方法来说主要需要解决的问题是如何找到一个足够大的空间，这里使用了Free-space map ( 自由空间图)，再这个图中每个entry对应一个block，它的值为一个数字，它表示相对应的block的剩余空间的大小，它是一个相对值，比如一个entry用3个bit，最大值为8，则一个entry为2的话就表示这个block有1/4可用；当block足够多时，一个个查看entry也可能会比较麻烦，还可以使用多级map，比如每四个entry为一组，则它的二级map中存放的是其中四个entry的最大值。这样当需要存储一个某一大小的数据时，只需要找到entry大于它的block就好

   * Sequential File Organization 顺序文件组织

     顾名思义是按照某种顺序存放记录，一般是用指针维护顺序，但是在多次增删之后数据之间的物理存储可能会很乱，这样可能会导致额外的I/O操作，需要定时对文件进行重组，这个代价是很高的

   * Multitable Clustering File Organization 多表聚集文件组织

     这种方式是一个文件中存放多个关系，它适用于那些经常需要做自然连接的关系，这样可用加快自然连接的速度，可是如果只是要读取其中一个关系，代价会增高

   * Partitioning 分片

     分片是将一个relation分块，分别存储在多个文件中，比如一个事务的表，我们将它分为今年的事物，去年的事务，前年的事务，将那些访问频率比较低的文件存储在速度比较慢的介质中，对于访问频率比较高的事务存储在速度比较快的存储介质中

   * B+-tree file organization（之后介绍）

   * Hashing file organization（之后介绍）

3. Data Dictionary Storage 数据字典存储

   数据字典中存放的数据是元数据，它包括关系的一些信息（关系名称、属性的名称类型长度、视图的名称和定义、完整性约束）、数据的一些统计信息、索引、用户信息等，由于对每一个relation进行访问时都需要对元数据进行读取，所以数据字典应该尽可能存储在速度很快的地方。

   在具体的存储形式上，我们把元数据也看作一个个表，按照关系的方式将其存储

4. Database Buffer 数据库缓冲区

   根据数据的局部性原理，我们刚刚操作的文件很可能很快就会被再次使用，我们使用缓冲区来减少IO次数，缓冲区实际上就是从内存中划分出一块单独的空间，它受Buffer manager (缓 冲区管理器 )的管理

   缓冲区管理器的操作逻辑是：

   当它需要从磁盘中读取一个block时，如果block已经在缓冲区中，直接从缓冲区读取；如果不在缓冲区，先要在缓冲区中分配一片空间，然后再将磁盘中要读取的block放到这片空间中

   当缓冲区管理器要分配一片空间时，如果缓冲区已经满了，它需要一个Buffer replacement strategy缓冲区替换策略选择某个block替换出去

   * Pinned block 在对一个block进行读写操作执勤，我们要将它pin钉在buffer中，避免在读取过程中被替换出去，在读写操作完成后将它unpin，当然可能同时多个进程需要读写一个block，因此有一个pin count，只有pin count为0对时候才可以将它替换出去

   * Shared and exclusive locks on buffer 共享锁和排它锁

     对于一个block，可以有多个进程同时对它进行读操作，但只能有一个进程进行写操作，为了实现这一点，我们设计了共享锁和排它锁，对于一个进程，当它有排它锁时，其他进行不能对同一个block进行写操作；对于一个多个进程可以有共享锁，可以同时读，一个block不能把共享锁和排它锁同时赋予给进程

   * Buffer-Replacement Policies 缓冲区替换策略

     大多数操作系统会采取LRU（least recently used strategy 最近最少策略），也就是将最近使用次数最少的block替换掉，但是LRU并不总是最有效的，在实际操作数据库时，可能会根据数据库的常用操作选择混合的替换策略 ，比如：Toss-immediate ( 立即 丢 弃 ) strategy、Most recently used (MRU) strategy，缓冲区控制器还可以根据数据的一些统计信息，计算一个block再次被使用的概率

   * Optimization of Disk Block Access 磁盘访问的优化

     在替换缓冲区内容时，还会常常涉及到写回的操作，我们可以通过对写回的顺序进行重排列来进行优化，优化方法如下：

     * forced output 强制输出（以后介绍）
     * Log disk ( 日志磁盘) 先把要写回的内容顺序写入一个磁盘中，当CPU比较空闲时再将磁盘中的内容写回内存
     * Nonvolatile write buffers 非易失写缓冲区：和日志磁盘的思想类似，只是写入的不是磁盘，而是一个非易失的RAM或flash中

5. Column-Oriented Storage 面向列的存储

   我们之前介绍的存储方式都是按照一个一个元组的顺序进行排列的，但有时候也可以按列存放，也就是按照属性存放，这种存储方式比较适合分析型任务，但是不太适合传统的事务处理（插入删除等操作）

### 4.3 索引

1. Basic Concepts 基础概念

   索引其实就是一种加速查找的数据结构，比如字典里面按照字母索引，一个索引有他对应的Search Key 搜索键（索引对应的属性集合），一个索引文件是由若干个index entries组成的，它包括Search Key 和指向该元组的实际存储位置的pointer

   衡量一个索引有效性的指标：访问类型（点查询/范围查询）、访问时间、插入时间、删除时间、空间大小

2. Ordered Indices 顺序索引

   顺序索引顾名思义就是index entries是按照search key的顺序存放的，索引可以分为primary index主索引（search key的顺序和该关系存储在文件中的顺序一致，不过主索引不一定就是关系的主键）、Secondary index 辅助索引（search key的顺序不同于文件中实际存储的顺序，辅助索引不支持范围查询，必须是稠密索引）

   索引还可以分为Dense Index Files 稠密索引（search key中有每一个索引记录）、Sparse Index 稀疏索引（search key中只包含部分的索引记录，它内存相对小一点，但是查找效率会稍微低，因为找到索引并不是直接就找到了记录，还需要再进行顺序的查找）根据两者的性质，我们有时可以建立Multilevel Index 多级索引，一般外层索引是稀疏的，内层索引是稠密的

   索引的更新：

   * 删除更新：稠密索引必须相应的删除索引、稀疏索引不一定
   * 插入更新：稠密索引必须相应的插入索引、稀疏索引不一定

3. B+ -Tree Index Files B+树索引文件

   * B+索引文件：

     B+索引文件说的是用B+树的数据结构来加速索引的查找，和ADS的B+树略有不同：

     * 根节点到所有叶节点的路径长度相等
     * 每一个非根/叶节点都有$\lceil n/2\rceil 到 n$个孩子
     * 每一个叶节点都有$\lceil (n-1)/2\rceil 到 n-1$个值
     * 如果根节点不是一个叶节点，它最少有2个孩子，如果根节点是一个叶节点，它有0～n-1个值

     对于B+树的每一个节点，它有n个指针和n-1个值，对于叶节点它最后一个指针指向的是下一个叶节点，其余指针指向的是相关记录的存储位置

     B+树的索引更新：插入、删除（ADS课程都有，不需赘述）

     一个例题：求的是索引文件的B+树高度和需要的block

     ![截屏2022-06-11 下午4.51.09](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261352695.png)

     > 解题思路：
     >
     > 1. 计算需要多少个block来存储这个关系：
     >
     > 先计算一个record所占用内存：18 + 8 + 2（smallint的大小）+ 40 = 68
     >
     > 然后一个block能够存储多少个record：4K = 4096 / 68 = 60.235 = 60 （注意要下取整）
     >
     > 2. 计算B+树的fan-out
     >
     > 对于一个索引文件，它的每一个block由一系列search key和pointer组成的index entry组成的，最后还有一个指针指向下一个block的位置
     >
     > （4096 - 4）（除去最后一个指针剩余可用用来存放index entry的空间大小）/（18 + 4）（search key + pointer） = 187
     >
     > 3. 计算B+树的可能高度
     >
     > 由于我们有100000个records，所以就有100000个index entry，由于n = 187， 我们根据B+树的定义可知，一个非叶节点的子节点数量为94～187个，一个叶节点的value的数量为93～186个，根节点的子节点数量为2～n个
     >
     > 因此我们可以计算高度为k的B+树的节点范围，如上所示

4. B+ -Tree Extensions B+树扩展

   * B+ -Tree File Organization B+树文件组织，与B+树索引文件不同，它的叶节点存放的不再是index entry，而是一个个文件，而由于文件的大小各不相同，我们不能再用简单的公式来进行B+树的一系列操作，这是树的合并和删除都是每三个节点一起看
   * Bulk Loading and Bottom-Up Build 多次插入和自底向上构建B+树：当一次性插入多个值，可以先对插入的内容进行排序，排序后再插入，可以减少一些IO次数；自底向上构建B+树是先把叶节点填满，然后根据每个叶节点，再生成上层节点的值，可以使B+树尽可能满
   * B树其实和B+树差不多，唯一区别就是非叶节点也会存储具体的数据，所以非叶节点就有两个指针，一个指向子节点，一个指向索引所对应的记录位置

5. Hash Indices 散列索引

   散列索引的思想就是将对于某一散列函数相同的index放到同一个bucket中，和B+树索引相比，散列索引只适合点查询，不支持批量查询

6. Multiple-Key Access 多码访问

   有时候我们数据库查询操作会对多个属性进行查找，比如要找金融系、工资为80000的教授，有两种查找索引的策略，第一个是分别对专业和工资两个索引进行查找，然后将查找的结果求交集；另一种方式是建立一个（专业，工资）有两个key的索引

7. Creation of Indices 索引的构建

   SQL语句中产检索引的语法`create index takes_pk on takes (ID,course_ID, year, semester, section)`

   删除索引的语法：`drop index takes_pk`

8. Write-Optimized Indices 写优化的索引

   对于索引的多次写操作，如果一次次进行的话，会多次访问内存，比较消耗时间。有两种方式可以优化写操作：

   * Log Structured Merge (LSM) Tree 日志结构合并树

     它的结构如图，原理就是利用内存的数据操作速度比外存快很多实现的，在要对索引进行写操作后，首先在内存的L0中进行排序和B+树构建，然后等L0满了就送到L1，对于每一个L如果满了就会将内容复制到下一层（大小为它k倍的L中），然后由于其中的数据都是排好序的，可以用自底向上的方式建立B+树，这种LSM tree的方式比较适合写操作频繁的数据库，但是如果删除或修改，往往代价比较高，一种处理删除的方式是在删除时并非直接将其删除，而是转换为插入一个delete entry，在下层L合并时，发现一个value和它对应的delete同时出现时就删掉

     <img src="https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261352718.png" alt="截屏2022-06-11 下午4.09.07" style="zoom:67%;" />

   * Buffer Tree 缓冲区树

     它的思想是在B+树的内部节点中预留一部分作为缓冲区，当数据插入到它下层的节点时，它先不插入，而是存放在缓冲区中，等到缓冲区满了再统一往下插入，减少了IO访问次数

9. Bitmap Indices

### 4.4 查询处理

1. Overview 概述

   对于一个查询的处理大致分为3步，首先是Parsing and translation 解释和翻译，见一个查询解释称关系代数表达式，然后Optimization 优化，最后Evaluation 执行，但是对于一个查询语句，它可以有多种关系代数表达式来描述，对于每一种关系代数表达式，执行方案也有很多种，这就需要数据库找到一种最优的方案

2. Measures of Query Cost 查询代价的计算

   查询代价我们一般就是指时间代价，对于本课程讨论的简单数据库，时间代价主要是因为一些磁盘访问的操作，对于一次磁盘访问，它的主要时间开销由：寻道时间、block读时间、block写时间三部分组成，我们通常用$t_T$表示tranfer一个block的时间$t_S$表示寻找一个block的时间，对于一次操作b个block，进行S次寻找的查询操作来说，时间代价是$b*t_T+S*t_S$，注意我们通常计算的时间代价是指最差情况下的时间代价

   由于我们写入内存还存在着各种各样的优化，在计算查询代价是，我们不考虑block写时间

3. Selection Operation 选择操作

   * 最普适地实现选择操作的方法是 linear search 线性查找，所花费时间为$b*t_T + t_S$
   * 聚集索引情况下，如果查找的结果唯一 $Cost = (h_i+ 1) * (t_T+ t_S)$h为索引B+树的高度
   * 聚集索引情况下，如果查找的结果不唯一 $Cost = h_i* (t_T+ t_S) + t_S+ t_T* b$
   * 辅助索引情况下，如果查找的结果唯一$Cost = (h_i+ 1) * (t_T+ t_S)$
   * 辅助索引情况下，如果查找的结果不唯一$Cost = (h_i+ n) * (t_T+ t_S)$

4. Sorting 排序

   外部排序算法

5. Join Operation 连接操作

   我们假设r为外关系，s为内关系，br为外关系的块数，bs为内关系的块数，nr为外关系的元组个数，ns为内关系的元组个数

   * Nested-Loop Join 嵌套循环连接

     嵌套循环连接是最朴素的连接做法，就是两个循环，各自遍历一个关系中的所有记录，如果内存只能存放一个block的话，操作代价为 br + nr * bs block transfers, plus br + nr seeks，如果两个关系中较小的关系可以直接存放在内存中，则操作代价为 br+ bs block transfers and 2 seeks

   * Block Nested-Loop Join 块嵌套循环连接

     相比于嵌套循环连接，按块嵌套连接是将两个关系都分成若干块，在每一个块内使用嵌套循环连接，它将上式中的nr减小到了br，如果内存只能存放一个block的话，操作代价为br* bs+ br block transfers + 2 * b rseeks，如果两个关系中较小的关系可以直接存放在内存中，则操作代价为 br+ bs block transfers and 2 seeks

   * 索引嵌套循环连接

     在索引嵌套循环连接中，若在内层循环的连接属性上有索引，可以用索引查找来代替file scan，操作代价br(tT+ tS) + nr* c，c表示对关系S进行单次选择操作的用时

   * Merge-Join 归并连接

     先将两个关系进行排序，然后按照顺序进行查找，类似于双指针算法，不需要循环，只使用于自然连接和等值连接，假设对每个关系分配bb个缓冲块

     $b_r + b_s\  block\ transfers + \lceil br / b_b \rceil + \lceil b_s / b_b \rceil  seeks + the\ cost\ of\ sorting\ if\ relations\ are\ unsorted$.

   * Hash-Join 散列连接

     将r和s的相同属性按照相同的哈希函数划分成nh个集合，那么对于r中的每一个元组，只需在一个子集合中找对应的s中的元组即可$3(b_r + b_s ) +4 * n_h\ block\ transfers + 2( \lceil b_r / b_b\rceil + \lceil b_s / b_b\rceil)\ seeks$

6. Other Operations 其他操作

7. Evaluation of Expressions 表达式执行

   * Materialization ( 物化 )：把中间结果存入磁盘
   * Pipelining （流水线 ）

### 4.5 查询优化

1. Introduction 介绍

   对于一个查询，我们往往有多种实现方式：一个表达式有很多等价形式、对每一个操作都有不同的实现形式

   evaluation plan 执行计划是指对每一步操作，都明确地指出算法的实现方式

   查询优化的基本步骤：

   * 用等价规则生成逻辑等价表达式
   * 得到替换的查询计划
   * 选择花费最小的执行计划

2. Transformation of Relational Expressions 关系代数表达式的转化

   有16条Equivalence Rules 等价规则

   启发式思路：尽可能早做select操作、project操作、多个关系的连接操作时先做中间结果小的连接

3. Statistical Information Estimation 统计信息的估计

   几个统计信息的概念：nr关系r的元组个数，br关系r的block块数、lr关系r中一个元组的大小、fr一个block能存放的元组个数，V（A，r）关系r中属性A所有的可能值

   有时候未来便于估计，我们会构造一个Histograms 数据直方图，来统计一些信息

   * Selection Size Estimation 选择操作估计——选择结果个数的估计

     $\sigma _{A=V}(r) = n / V(A,r)$如果A是一个主键，则结果为1

     $\sigma _{A<=V}(r) = n_r\frac{v-min(A,r)}{max(A,r)-min(A,r)}$，如果有直方图，估计会更准确，如果连最大值最小值都没有，就按照nr / 2估计

     对于某些复杂的选择操作，我们引入selectivity 选择概率，si表示满足某条件的元组的个数

     对于Conjunction 交集操作：$n_r\frac{s_1*s_2*...s_n}{n_r^n}$

     对于Disjunction 并集操作：$n_r*(1-(1-\frac{s_1}{n_r})*...*(1-\frac{s_n}{n_r}))$

   * Estimation of the Size of Joins 连接操作估计

     关系r和关系s进行笛卡尔积，最终结果会产生$n_r*n_s$个元组，每个元组的大小为$l_r+l_s$

     如果R和S交集为空集，则自然连接的结果和笛卡尔积结果相等

     如果R和S的交集是R的一个key，那么元组数不会超过ns

     如果R和S的交集是R的一个foreign key，那么元组数等于ns

     一般情况下，R和S的交集不是码，$size = min(\frac{n_r*n_s}{V(A,n)}, \frac{n_r*n_s}{V(A, n_S)})$

   * 其他操作的估计

     project：size = V(A, r)

     aggregate: size = V(G, r)

     set operation: 并运算（大小之和）、交运算（两者中较小者）、差运算（被减集合的大小）

     outer join: 左外连接（自然连接+左关系的大小）、右外连接（自然连接+右关系的大小）

4. Choosing Evaluation Plans 执行计划的选择

5. Materialized Views 物化视图

## 5 事务管理

### 5.1 事务

1. Transaction Concept 事务基本概念

   一个事务就是一个程序执行的单元，它有四个特性：

   * Atomicity 原子性：事务所有的操作要么全部发生，要么全部不发生，事务执行只有两种结果commit完全执行和rollback 回滚
   * consistency 一致性：在没有其他事务并发执行的情况下，保持数据的一致性
   * Isolation 隔离性：事务在并行执行的时候不能感知到其他事务的发生
   * Durability 持久性：一个事务成功完成后它对数据库的修改的永久的

2. Concurrent Executions 并发执行

   并发执行可能会导致一系列的问题，我们对并发执行的执行方案要有很好的设计，我们引入了Schedule 调度的概念，调度是指一系列的用于指定并发事务的顺序执行的指令，它需要包含事务中的所有指令，需要保证单个事务中的指令的顺序不发生改变

   * serial schedule 串行调度：一个事务调度完成后再执行另一个事务
   * equivalent schedule  等价调度：改变执行的顺序但是和原来等价

3. Serializability 可串行化

   在接下来的分析中，我们只考虑读写两种操作，如果一个调度与串行调度是等价的，那么它就是一个可串行化的调度，一个事务的可串行化调度往往有很多，我们一般不需要全部找出，我们可以找它的一个子集View serializability （ 视图 可串行化）以及这个子集的子集Conflict serializability ( 冲突可串行化 )

   * Conflict serializability ( 冲突可串行化 )
     * 冲突(conflict)：当两个事务对相同数据操作时，如果两个都是读操作，则不发生冲突，有一个事务是进行写操作，就会发生冲突
     * 非冲突指令交换：如果I和J是调度S的两条连续性指令，若两者属于不同事务并且不发生冲突，那么可以交换两者的顺序得到S的一个等价调度S‘
     * conflict equivalent) 冲突等价：如果调度S经过一系列的非冲突指令交换后得到调度S‘，那么S和S’就是冲突等价的
     * conflict serializable 冲突可串行化：如果一个调度和一个串行调度冲突等价，那么这个调度就是冲突可串行化的
   * View Serializability （ 视图可串行化）
     * 所有冲突可串行化的调度都是视图可串行化的
     * 那些不属于冲突可串行化，但是属于视图可串行化的都是有blind writes 盲写，就是对于同一个数据连续进行多次写操作，除了最后一次写操作，中间的写操作都可以颠倒顺序

4. Testing for Serializability 可串行的测试

   为了测试一个调度是否是冲突可串行化的，我们引入了Precedence graph （前 驱图 ）的工具，它是由调度S构造一个有向图G = (V, E)，图中的顶点V是由参与调度的事务组成，边集包含所有的冲突操作，表示两个事务执行的先后顺序，当一个调度的前驱图是无环图时，这个调度时冲突可串行化的，对于一个无环图，可以选择一个合适的执行顺序

   Lock-Based Protocols

5. Recoverability 可恢复性

   * Recoverable schedule （可恢复调 度）：对于每一对事务Ti和Tj，如果Tj读取了之前由Ti所写的数据项（被称为Tj依赖于Ti），那么Ti应该先于Tj执行commit指令；如果不满足可恢复调度，就会导致dirty read
   * Cascading rollback 级联回滚 ：一个事务的回滚导致一系列事务都要发生回滚，这个过程代价很大，我们要尽可能避免级联回滚
   * Cascadeless Schedule 无级联调度：是一种相比可恢复调度更严格的调度，对于每一对事务Ti和Tj，如果Tj读取了之前由Ti所写的数据项（被称为Tj依赖于Ti），那么在Tj读取之前，Ti已经被commit；所有的无级联调度都是可恢复调度

6. Implementation of Isolation

7. Transaction Definition in SQL

### 5.2 Concurrency Control 并发控制

1. Lock-Based Protocols 分锁协议

   lock锁是一种控制并发访问的机制，它分为exclusive (X) mode 排它锁和shared (S) mode. 共享锁，我们通过concurrency-control manager 并发控制器来给事务分配锁，只有当一个事务具有锁时，才有对相应数据的操作权限，相关内容我们在数据库缓冲区部分有所介绍

   locking protocol 分锁协议是一系列给事务授权和收回锁的规则。

   Deadlock 死锁：简单来说，就是两个事务都要申请锁（不同的数据），但是这个数据的锁被对方使用，两个事务都在等对方进行，这是程序无法进行，称为死锁，一般对于这种情况会将其中一个事务进行回滚，starvation 一个事务一直被回滚

   我们为了获得一种冲突可串行化的调度，有一种Two-Phase Locking Protocol 两阶段锁协议，它将每一个事务分为两个阶段，一个是Growing Phase 只获得锁，不释放锁；另一个是Shrinking Phase，只释放锁，不获得锁；lock point是说一个事务最后一次获得锁的时间点，最终得到的调度是按照它们lock point的先后顺序的可串行化调度

   两阶段锁协议虽然保证了调度是可串行化的，但是仍然可能会遇到死锁问题，这时我们还有两种更严格的规则：

   * Strict two-phase locking 一个事务必须要等到结束之后才会释放所有的排它锁，它保证了调度的可恢复性和避免了级联回滚
   * Rigorous two-phase locking 一个事务必须要等到结束之后才会释放所有锁，此时事务的串行化是按照它们commit的顺序

   Lock Conversions 有的两阶段锁协议是包含锁转换的，就是在第一个阶段也允许共享锁升级为排它锁，第二阶段允许排它锁降级为共享锁

   锁的实现：我们设置一个lock manager 锁控制器，用来处理锁请求，它是一个类似哈希表的数据结构，每一个bucket存放多个数据item，每一个item都有一个链表，连接着与该数据相关的锁请求，具体结构如图：

   ![截屏2022-06-12 下午4.30.11](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261353096.png)

2. Deadlock Handling 死锁处理

   死锁的预防机制：

   * pre-declaration：在一个事务开始之前，先申请所有它用到的锁
   * graph-based protocol
   * Wait-die scheme：如果一个事务申请的锁被其他事务占用，老的事务等待新的事务，新的事务不会等待老的事务，直接die
   * Wound-wait scheme：如果一个事务申请的锁被其他事务占用，老的事务回滚，新的事务等待
   * Timeout-Based Schemes：如果一个事务申请的锁被其他事务占用，等待一段时间，超过该时间就回滚

   死锁检测机制：

   Wait-for graph：节点为事务，如果事务I需要等待事务J释放一个数据锁，那么就画一条I到J到有向边，如果图中有环，则说明存在死锁

   死锁恢复：

   * 选择代价最小的事务进行回滚
   * 回滚分为部分回滚和全部回滚
   * 解决饿死问题：保证一个事务回滚次数有限

3. Multiple Granularity 多粒度

   多粒度说的是数据的大小，Fine granularity (细粒度)说的是一个元组或者一个数据，Coarse granularity (粗粒度)说的是一个数据库或者一个关系，我们加的锁可以有不同的粒度，细粒度的锁高并发但是加大锁的开销，粗粒度的锁低并发，但是锁的开销小，数上的每一个节点都可以单独加锁

   ![截屏2022-06-12 下午4.54.17](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206261353000.png)

   Intention Lock Modes 意向锁：

   * intention-shared (IS) 允许在子孙节点添加共享锁
   * intention-exclusive (IX) 允许在子孙节点添加共享锁或者排它锁
   * shared and intention-exclusive (SIX) 在当前节点添加共享锁，在子孙节点添加排它锁

4. Insert and Delete Operations



### 5.3 恢复系统

1. Failure Classification 故障分类

   * transaction failure 事务故障：包括系统错误和逻辑错误，死锁就是一种系统错误
   * system crash 系统崩溃：软硬件出错导致系统崩溃。易失性存储器内容丢失，非易失性存储器完好
   * disk failure 磁盘故障：数据传送过程中由于磁头损坏或者故障导致磁盘上的内容丢失

2. Recovery and Atomicity 恢复和原子性

   Recovery Algorithms 恢复算法：在故障发生后仍能确保数据库的一致性、事务的原子性和持久性的算法。这就需要每次在修改数据库之前，都要向稳定的存储器描述修改信息，这样一来发生错误就可以根据存储器的信息进行回滚，保证事务的原子性

3. Log-Based Recovery 基于日志的恢复

   log日志被存储在一个稳定的存储器中，在对数据库进行相关操作之前，先在日志中对该操作进行记录：

   * 事务开始 `<Ti satrt>`
   * 写操作 `<Ti, X, V1, V2>`Ti表示事务、X表示要写的数据，V1是原来的值，V2是写入的值
   * 事务结束或终止`<Ti commit/abort>`

   对数据库修改操作根据时间不同分为两类：

   * immediate-modification 立即修改：只要日志记录了，随时能写进磁盘，不需要等待事务结束
   * deferred-modification 延迟修改：必须要等事务结束之后才进行实际的修改操作

   事务提交之后，修改会先放在缓冲区里，至于何时真正写入磁盘，并不一定

   故障恢复的两个操作：

   * Undo (撤销)：进行撤销操作时需要在日志中写入compensation log 补偿日志 `<Ti, X, V>`V为修改之前的值，当故障恢复时，对于那些没有结束的事务，要执行撤销操作
   * redo（重做）：不需要写入日志，在故障恢复时，对于那些已经结束的事务，执行重做操作

4. Checkpoints 检查点

   在原来的日志恢复算法中，在故障发生时，要检查每一个事务是否结束，这个代价会比较大，加入检查点大优化可以将日志分成若干段，故障发生时只需要关注上一个检查点之前到位置即可。

   在一个检查点上，要把所有的日志记录写进稳定存储器中，所有修改过的缓冲块写到磁盘中。在日志中写入`<checkpoint L>`，其中L为checkpoint时还在进行的事务。注意做检查点时，当前所有的操作都会停止。

   有检查点优化的故障恢复算法：
   先进行redo操作，找到最近的检查点记录，找到所有已经结束的事务，从前往后进行redo操作；然后对于仍在L中的事务，从后向前撤销所有操作

5. Buffer Management 缓冲区管理

6. Early Lock Release and Logical Undo Operations

7. ARIES Recovery Algorithm

   * ARIES与其他恢复算法的区别：
     * 使用日志序列号（LSN）来标记日志记录，并将LSN存储在数据库页中，来标识哪些操作已经在一个数据库页中实施过了
     * 支持物理逻辑redo操作
     * 使用dirty page table来最大限度地减少恢复时不必要的重做
     * 使用fuzzy checkpoint机制，只记录脏页信息和相关的信息
   * 数据结构
     * log sequence number(LSN)：日志序列号，用于标识每一条日志记录，由一个文件号以及在该文件中的偏移量组成，方便快速访问
     * PageLSN：每一个数据库页也要维护一个PageLSN，每当一个更新操作发生在某页，该操作将其日志的LSN存储在该页的PageLSN域中。在恢复的撤销阶段，LSN值不超过PageLSN的日志记录就不会在该页上执行。
     * log record：每一条日志记录的结构为 LSN TransID PrevLSN RedoINfo UndoInfo，其中PrevLSN为同一事务的前一条日志记录的LSN；补偿日志记录 (compensation log record, CLR)：在undo时所做的日志记录，组成为 LSN TransID UndoNextLSN RedoInfo，其中UndoNextLSN记录更早的需要undo的记录
     * DirtyPage Table：存储在缓冲区中，记录已经被更新过的page的表，组成：每一页的pageLSN，记录该页最近由哪一个日志项修改；每一页的RecLSN，记录还没有存储在磁盘中的第一条操作
     * checkpoint log record：包含dirtypage table和当前活跃的事务，对于每一个当前活跃的事务，记录它们的LastLSN，也就是该事务最后一条日志
   * ARIES恢复算法
     * 分析阶段：决定哪些事务要被撤销，哪些页在崩溃时是脏的，以及重做阶段应该从哪个LSN开始
       * 找到最后的完整检查点日志记录：读入脏页表，设置RedoLSN等于脏页表中最小的RecLSN，也就是第一条没有存储在磁盘中的操作（如果脏页表为空则设置为checkpoint的LSN）。设置undo- list为checkpoint中的事务，读取每一个undo-list中每一个事务的最后一条记录的LSN。
       * 从检查点开始向前操作：如果发现不在undo-list中的事务的日志记录就写入undo-list；当发现一条更新记录时，如果这一页不在脏页表中，就用该记录的LSN作为recLSN写入脏页表；只要找到一个事务的end日志记录，就把该事务从undo-list中删除；直到undolist的每一个事务都到了最后一条结束。
       * 分析结束后，用RedoLSN决定从哪里开始redo，脏页表中的每一页的RecLSN被用来最小化redo的工作量。所有的undo-list事务都需要回滚
     * redo阶段：从RedoLSN开始正向扫描，当发现一条更新记录，如果这一页不在脏页表或者这一条记录的LSN小于页面的RecLSN，就忽略这一条；否则就从磁盘中读取这一页，如果磁盘中这一页的PageLSN比这一条要小，就redo，否则就忽略
     * undo阶段：从日志末尾开始向前搜索，undo所有undo-list中的事务，即遇到一条记录时生成一个包含执行操作的CLR，设置CLR的undoNextLSN为待undo记录的PrecLSN。如果遇到符合以下条件的记录则可以skip：用分析阶段的最后一个LSN来找到每个日志最后的记录；学、每次选择一个最大的LSN对应的事务undo；在undo一条记录之后，对于普通的记录，将NextLSN设置为PrevLSN；对于CLR记录，将NextLSN设置为UndoNextLSN