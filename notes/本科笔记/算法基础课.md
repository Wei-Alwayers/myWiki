# 算法基础课

Created: November 22, 2021 6:58 PM
Created by: Anonymous
Property 1: May 30, 2022 9:37 PM
Tags: 算法

# 1. 基础算法

## 1.1 排序

### 1.1.1 快速排序 —— 分治

$T_{ave}(N) = O(NlogN)$

基本思想：

1. 确定分界点：任意确定，可以是q(l), q(r), q((l+r)/2), 随机
2. 调整区间：使左边区间满足≤x，右边区间满足≥x（x在左右都行，分界点不一定为x）
3. 递归处理左右两段
- 关键：第二步——调整区间
1. 方法一：暴力算法，增大内存空间的消耗
    1. a[ ], b[ ]
    2. q[ l ~ r ] → a[ ] /  b[ ]
    3. a[ ]  → q[ l ], b[ ] → q[ r ]
2. 方法二：优美解法
   
    通过左右两个指针各自向中间移动，左指针i向右移动，直到*i ≥ x停下；右指针j向左移动，直到*j ≤ x停下；swap（*i， *j）；重复以上操作直到i， j相遇
    
    ```cpp
    void quick_sort(int q[], int l, int r)
    {
        if (l >= r) return;
    
        int i = l - 1, j = r + 1, x = q[l + r >> 1];
        while (i < j)
        {
            do i ++ ; while (q[i] < x);
            do j -- ; while (q[j] > x);
            if (i < j) swap(q[i], q[j]);
        }
        quick_sort(q, l, j), quick_sort(q, j + 1, r);
    }
    ```
    

### 1.1.2 归并排序 —— 分治

$T(N) = O(NlogN)$

基本思想：

1. 确定分界点：$mid = (l + r)/2$， 左边的数≤x， 右边的数≥x
2. 递归排序
3. 归并：合二为一
- 关键：第三步 —— 归并

两个数组最小值比较，取较小值放入result[ ]中

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}

```

## 1.2 二分

### 1.2.1 整数二分

- 适用条件：有单调性的一定可以二分，但是可以二分的不一定要有单调性
- 本质： 找到一个性质可以将区间一分为二，一半满足该性质，另一半不满足该性质

对于离散型的数据进行二分，分界点一定有两个，各自有不同的算法

1. 算法一
   
    $mid = (l + r +1)/2$;
    if(check(mid)):
          true → [ mid, r]
          false → [l, mid - 1 ] 
    
2. 算法二
   
    $mid = (l + r)/2$
    
    if( check( mid )):
        true → [ l . mid ]
        false → [ mid + 1, r ]
    

具体写法：做题时先根据check函数的数组更新方式不同确定mid的定义方式（是否 +1）

- 思想二分后选择包含答案的区间进行下一步二分操作，直至区间长度变为1
- 二分一定是有解的，注意选择性质的边界

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

- 自我总结
    - 在二分查找时，应该先确定一个能够将数组一分为二的特性，同时这个特性还需要满足我们要找的数为某一个端点，比如我们在一个升序排列的数组中找某一元素的起始位置，我们就可以将其翻译为找大于等于该元素的区间的左端点。
    - 应该先写好check函数然后再将bsearch函数部分进行补充
    - 当选择l = mid还是r = mid时，我们需要认真考虑我们最终想要找的结果是在mid的左边还是右边
    - 对于模版的记忆可以有这样一条规律：在if-else语句中，l总是比r大1，而且如果在if-else中有+1，则mid定义中就没有+1

### 1.2.2 浮点数二分

边界问题不是很复杂，实现比较简单：

```cpp
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

- tips: 一般精度的确定要比保留小数的位数多两位，保证结果准确

## 1.3 高精度

- 高精度的运算一般指的是与大整数（位数≤10^6)有关的，与之相对的是小整数（数值≤10^9)
- 大整数的存储：用数组进行逆序存储
例如：“123456789” → a[ 9 ] = {9, 8, 7, 6, 5, 4, 3, 2, 1}

### 1.3.1 高精度加法

C = A + B(A, B均为大整数）：基本类似于人类竖式算法，注意进位即可

```cpp
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

### 1.3.2 高精度减法

C = A - B（A、B均为大整数）；同样算法类似于人类的竖式算法，不过为了简便，应该保证A ≥ B，注意借位和前导零的问题

```cpp
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 1.3.3 高精度乘法

$C= A*b（A为大整数，b为小整数）$算法思路不完全等同于人类的乘法运算，这里是将b看作一个整体，按位进行运算，同样要注意的是位数的增加

```cpp
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

### 1.3.4 高精度除法

$C= A / b(A为大整数，b为小整数）$基本类似于人类的除法，不过不同于其他几个运算，除法运算是从最高位开始计算的，同时也需要注意前导零的问题

```cpp
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## 1.4 前缀和与差分

### 1.4.1 前缀和

前缀和并不是一种特定的算法，而更多的是一种算法思想，用来对特定问题进行简化
前缀和的定义：对于下标从1开始的数组a[n]，其前缀和$s_i = a_1 +a_2+... +a_i$

- 一维前缀和
    - 如何求前缀和：s[ i ] = s[ i-1 ] + a[ i ]
    - 前缀和作用：快速计算数组a[ n ]下标[ l, r ]部分数组的和
    
    ```cpp
    S[i] = a[1] + a[2] + ... a[i]
    a[l] + ... + a[r] = S[r] - S[l - 1]
    ```
    
- 二维前缀和
    - 如何求前缀和：$S_{i,j} = S_{i-1,j}+S_{i, j-1}-S_{i-1, j-1} + a_{i, j}$
    - 前缀和的作用：快速求部分子矩阵的和
    
    ```cpp
    S[i, j] = 第i行j列格子左上部分所有元素的和
    以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
    S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
    ```
    

### 1.4.2 差分

差分是前缀和的一个逆运算，也就是说，已知一个数组a[ n ], 我们构造一个数组b[ n ]，使a[ n ] 为b[ n ]的前缀和。
在差分的运算时，一个非常重要的思想是我们只需要考虑一个增值操作（让下标[ l, r ]的$a_i$各自增加常数c），而不用考虑如何构造b。这使得我们只需要将初始状态假设为0，然后以此对[i, i]增量$a_i$操作。

- 一维差分
    - 作用：用O(n)的时间复杂度从b得到a
    - 增值操作
    
    ```cpp
    给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
    ```
    
- 二维差分
    - 增值操作：
    
    ```cpp
    以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
    S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
    ```
    

## 1.5 双指针算法

核心思想：将$O(N^2)的算法优化成O(N)$的算法

```cpp
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j <  n && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

常见问题做法：先想到朴素的暴力算法，然后寻找i，j之间的关系对原算法进行优化

- 个人总结：在进行双指针优化时，找到某个单调性的特征是优化的关键

## 1.6 位运算

- 快速得到二进制数n的第k位
  
    ```cpp
    n >> k & 1
    ```
    
- lowbit操作
  
    lowbit(n)：返回二进制数n的最后一位1，例如$lowbit(1010) = 10; lowbit(101000) = 1000$
    
    ```cpp
    lowbit(n) = n & -n
    ```
    
    常见应用：统计二进制数n中1的个数
    

## 1.7 离散化

- 整数、保序的离散化

对于值域 >> 值的个数这样非常稀疏的数据，常用到离散化
离散化的本质即是建立一种映射关系，也就是对原数组进行排列后用下标表示其映射后的值

```cpp
	a[ ] : 1, 3, 100, 2000, 50000
	映射	 : 0, 1, 2,   3,    4
```

因此，离散化往往需要解决两个问题

- a[ ] 中可能具有重复元素 → 对a[ ]进行去重操作
- 如何算出数组中元素x离散化后的值 → 二分确定其位置

```cpp
// 常用的对数组进行去重的方法
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

## 1.8 区间合并

算法目的：合并所有有交集的区间

```cpp
例如c为a、b两个区间合并而成
a: _________
b:      _______
c: ____________

```

算法思想：

1. 按区间左端点进行排序
2. 对于某一操作区间，根据下一个区间与其关系进行下一步操作：
    1. 在原区间内部 → 保持不变
    2. 左端点在原区间内部，右端点在原区间外部 → 更新右端点
    3. 左端点在原区间外部 → 将原区间进行保存，更新操作区间为本区间
    

```cpp
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9; //初始时将左右端点设置为正负无穷
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}

```

# 2. 数据结构

## 2.1 链表与邻接表

这里我们采用数组模拟的方式表示链表和邻接表，单链表往往用于树或图的表示，双链表往往用于对某些算法进行优化。而邻接表实质上就是多个单链表的结合。

### 2.1.1 单链表

```cpp
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

### 2.1.2 双链表

```cpp
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化,将0当作head，1当作tail
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

## 2.2 栈与队列

栈与队列在c++中都有相应的stl库，不过用数组将其实现可以提高程序运算的效率，对于队列，还可以直接获得队尾元素，比较方便

### 2.2.1 栈

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

### 2.2.2 队列

- 普通队列
  
    ```cpp
    // hh 表示队头，tt表示队尾
    int q[N], hh = 0, tt = -1;
    
    // 向队尾插入一个数
    q[ ++ tt] = x;
    
    // 从队头弹出一个数
    hh ++ ;
    
    // 队头的值
    q[hh];
    
    // 判断队列是否为空
    if (hh <= tt)
    {
    
    }
    ```
    
- 循环队列(并不常用）
  
    ```cpp
    // hh 表示队头，tt表示队尾的后一个位置
    int q[N], hh = 0, tt = 0;
    
    // 向队尾插入一个数
    q[tt ++ ] = x;
    if (tt == N) tt = 0;
    
    // 从队头弹出一个数
    hh ++ ;
    if (hh == N) hh = 0;
    
    // 队头的值
    q[hh];
    
    // 判断队列是否为空
    if (hh != tt)
    {
    
    }
    ```
    

### 2.2.3 单调栈

应用场景：给定一个序列，求序列中每个数左边（右边）离它最近的比它小的数

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

### 2.2.4 单调队列

应用场景：求移动窗口中的最大（最小）值

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

- 一点思考：

做单调栈或单调队列的问题思路是这样的：首先思考用栈或队列暴力做法，然后看其中哪些元素是可以被删去的，然后就可以观察剩余的栈或队列中的元素是否有单调性

## 2.3 KMP算法

```cpp
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}

```

## 2.4 trie树

特性：快速储存和查找字符串集合的数据结构

![Untitled](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206262012673.png)

性质：

1. **根节点不包含字符，除根节点外每一个节点都只包含一个字符**
2. **从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串**
3. **每个节点的所有子节点包含的字符都不相同**

模版题：统计字符串出现的次数

```c
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

## 2.5 并查集(union  or find)

union: 将两个集合合并

find: 寻找数字所在的集合

原理：每个集合用一棵树表示，树根编号就是整个集合的编号，每个节点储存着其父节点，也就是p[x]表示x的父节点

- 如何判断树根 if p[x] == x
- 如果求x的集合编号 while(p[x] ≠ x] x= p[x]
- 如何合并两个集合 p[x] = y

优化：

- 路径压缩
- 按秩合并（不常用）

```c
1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);

(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);

(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

## 2.6 堆

常用操作：

- 插入一个数
- 求最小值
- 删除最小值
- 删除任意一个元素
- 修改任意一个元素

实现方式：

up：上滤

down：下滤

```c
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

## 2.7 哈希表hash

存储方式：

- 开放式寻址
- 拉链法

作用：对复杂的数据结构进行映射（离散化是一种特殊的哈希）

实现思路：

- x mod 10^5(这个数往往取一个大于题目要求的最小质数）
- 处理冲突
1. 拉链法
   
    ```c
    (1) 拉链法
        int h[N], e[N], ne[N], idx;
    
        // 向哈希表中插入一个数
        void insert(int x)
        {
            int k = (x % N + N) % N;
            e[idx] = x;
            ne[idx] = h[k];
            h[k] = idx ++ ;
        }
    
        // 在哈希表中查询某个数是否存在
        bool find(int x)
        {
            int k = (x % N + N) % N;
            for (int i = h[k]; i != -1; i = ne[i])
                if (e[i] == x)
                    return true;
    
            return false;
        }
    ```
    
2. 开放寻址法：
   
    开放寻址法申请的数组大小往往是题目所要求大小的2～3倍
    
    ```c
    (2) 开放寻址法
        int h[N];
    
        // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
        int find(int x)
        {
            int t = (x % N + N) % N;
            while (h[t] != null && h[t] != x)
            {
                t ++ ;
                if (t == N) t = 0;
            }
            return t;
        }
    ```
    
3. 字符串哈希（前缀哈希法）
   
    思想：
    
    - 将字符串每一个前缀进行哈希
      
        如“ABCDEFG” → H[1] = "A"的哈希， H[2] = "AB"的哈希， H[3] = "ABC"的哈希......
        
    - 把字符串看作是P进制的数
      
        如“ABCD” ⇒  $(1234)_P$ ⇒ $(1*P^3+2*p^2+3*p^1+4*p^0)_{10}mod Q$d
        
    
    注意：
    
    - 不能将字符映射成0
    - （假定）不存在冲突
      
        P = 131 or 13331
        Q = $2^{64}$ ← 往往用unsigned long long存储，从而不用取模
        
    
    作用：
    
    计算任意子字符串的哈希
    
    公式：$h[R]-h[L]*P^{R-L+1}$
    
    应用：
    
    快速判断两个字符串是否相等
    
    ```c
    核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
    小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果
    
    typedef unsigned long long ULL;
    ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
    
    // 初始化
    p[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }
    
    // 计算子串 str[l ~ r] 的哈希值
    ULL get(int l, int r)
    {
        return h[r] - h[l - 1] * p[r - l + 1];
    }
    ```
    
    ## 2.8 C++ STL
    
    - vector
      
        ```c
        		vector, 变长数组，倍增的思想
            size()  返回元素个数
            empty()  返回是否为空
            clear()  清空
            front()/back()
            push_back()/pop_back()
            begin()/end()
            []
            支持比较运算，按字典序
        ```
        
    - pair
      
        ```c
        		pair<int, int>
            first, 第一个元素
            second, 第二个元素
            支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
        ```
        
    - string
      
        ```c
        		string，字符串
            size()/length()  返回字符串长度
            empty()
            clear()
            substr(起始下标，(子串长度))  返回子串
            c_str()  返回字符串所在字符数组的起始地址
        ```
        
    - queue
      
        ```c
        		queue, 队列
            size()
            empty()
            push()  向队尾插入一个元素
            front()  返回队头元素
            back()  返回队尾元素
            pop()  弹出队头元素
        ```
        
    - priority_queue
      
        ```c
        		priority_queue, 优先队列，默认是大根堆
            size()
            empty()
            push()  插入一个元素
            top()  返回堆顶元素
            pop()  弹出堆顶元素
            定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;
        ```
        
    - stack
      
        ```c
        		stack, 栈
            size()
            empty()
            push()  向栈顶插入一个元素
            top()  返回栈顶元素
            pop()  弹出栈顶元素
        ```
        
    - deque
      
        ```c
        		deque, 双端队列
            size()
            empty()
            clear()
            front()/back()
            push_back()/pop_back()
            push_front()/pop_front()
            begin()/end()
            []
        ```
        
    - set, map
      
        ```c
        set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
            size()
            empty()
            clear()
            begin()/end()
            ++, -- 返回前驱和后继，时间复杂度 O(logn)
        
            set/multiset
                insert()  插入一个数
                find()  查找一个数
                count()  返回某一个数的个数
                erase()
                    (1) 输入是一个数x，删除所有x   O(k + logn)
                    (2) 输入一个迭代器，删除这个迭代器
                lower_bound()/upper_bound()
                    lower_bound(x)  返回大于等于x的最小的数的迭代器
                    upper_bound(x)  返回大于x的最小的数的迭代器
            map/multimap
                insert()  插入的数是一个pair
                erase()  输入的参数是pair或者迭代器
                find()
                []  注意multimap不支持此操作。 时间复杂度是 O(logn)
                lower_bound()/upper_bound()
        
        unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
            和上面类似，增删改查的时间复杂度是 O(1)
            不支持 lower_bound()/upper_bound()， 迭代器的++，--
        ```
        
    - bitset
      
        ```c
        		bitset, 圧位
            bitset<10000> s;
            ~, &, |, ^
            >>, <<
            ==, !=
            []
        
            count()  返回有多少个1
        
            any()  判断是否至少有一个1
            none()  判断是否全为0
        
            set()  把所有位置成1
            set(k, v)  将第k位变成v
            reset()  把所有位变成0
            flip()  等价于~
            flip(k) 把第k位取反
        ```
        

# 3. 搜索与图论

## 3.1 DFS和BFS

|  | 数据结构 | 空间 | 特点 |
| --- | --- | --- | --- |
| DFS | stack | O(N) | 不具有最短路 |
| BFS | queue | O(2^h) | 有最短路 |
- DFS：
  
    关键步骤：回溯、剪枝
    关键在于搜索的顺序（可以用树的形式理解），并无常用框架。
    
- BFS：
  
    ```cpp
    queue <- 初始
    
    while( queue不空）
    {
    		t <- 队头
    		拓展t
    }
    ```
    

## 3.2 树与图的遍历、拓扑排序

树是一种特殊的图（无环、连通），而且无向图也可以看作是一种特殊的有向图，因此图和树的问题都可以简化为研究有向图的问题。

有向图的存储：

- 邻接矩阵: 空间复杂$O(N^2)$,用的较少
- 邻接表：比较常用

```cpp
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

图和树的遍历：

- 深度优先遍历
  
    ```cpp
    int dfs(int u)
    {
        st[u] = true; // st[u] 表示点u已经被遍历过
    
        for (int i = h[u]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (!st[j]) dfs(j);
        }
    }
    ```
    
- 宽度优先遍历
  
    ```cpp
    queue<int> q;
    st[1] = true; // 表示1号点已经被遍历过
    q.push(1);
    
    while (q.size())
    {
        int t = q.front();
        q.pop();
    
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (!st[j])
            {
                st[j] = true; // 表示点j已经被遍历过
                q.push(j);
            }
        }
    }
    ```
    

拓扑排序：宽度优先遍历的一种应用

时间复杂度：$O(m+n)$, n表示节点数，m表示边数

```cpp
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

## 3.3 最短路

概述：

- 单源最短路
    - 所有边权都是正数
        - 朴素Dijkstra算法   —— 稠密图
        - 堆优化版的Dijkstra算法 —— 稀疏图
    - 存在负权边
        - Bellman-Ford 算法
        - SPFA 算法
- 多源汇最短路 Floyd算法

1. 朴素Dijkstra算法

时间复杂是 O(n2+m)
n表示点数，
m表示边数

算法思路：

- dis[1] = 0, dis[r] = infinity
- for i 1~N
    - t ← 不在S中，距离最近的点
    - s ← t
    - 用t来更新其他所有的距离
    

代码模版：

```cpp
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

1. 堆优化版的Dijkstra算法

时间复杂是 O(mlogn)
n表示点数，
m表示边数

优化步骤：t ← 不在S中，距离最近的点

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

1. Bellman-Ford 算法

时间复杂是 O(mn)
n表示点数，
m表示边数

算法思路：

for n次
备份
for 所有边 a, b, w
      dist[b] = min(dist[b], dist[a] + w)

tips: 在递归k次后，dist表示不超过k条边的最短路距离

特殊应用：有边数限制的最短路

```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

1. SPFA 算法

时间复杂是 O(m)，最坏为O(mn)
n表示点数，
m表示边数

SPFA算法是对Bellman-Ford算法的优化，采用BFS优化思路

算法思路：

queue ← 1
while queue不空
      t ← q.front( )
     q.pop( )
     更新所有t的出边
             更新的边加入queue

tips: 很好用，应用比较广泛

应用：用于判断负环

dist[x]: 表示1～x的最短路
cnt[x]: 表示该最短路的边数
if cnt[x] ≥ n ⇒ 有负环

```cpp
nt n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

1. Floyd 算法

时间复杂是 O(n^3)
n表示点数

d[i][j]: 邻接矩阵存储边
for (k 1~N)
    for(i 1~N)
          for(j 1~N)
               d[i][j] = min (d[i][j], d[i][k], d[k][j])
d[i][j]: i到j的最短路

```cpp
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

```

## 3.4 最小生成树

概述：

最小生成树

- Prim算法
    - 朴素版Prim算法 稠密图
    - 堆优化Prim算法 稀疏图
- Kruskal算法
1. 朴素版Prim
    - 时间复杂度：
    
    时间复杂度是 O(n^2+m)
    n表示m表示边数
    
    - 算法思路：
      dist[i] = ∞, S: 已在通路上的点的集合
      for(i = 0; i < n; i++)
      
        找到集合外最近的点 → t
      
        用t来更新其他点到集合的距离
        st[t] = true
      

```cpp
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中

// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

1. Kruskal算法：
    - 时间复杂度：
      
        时间复杂度是 O(mlogm)
         n表示点数，
        m表示边数
        
    - 算法思路：
        - 将所有边按权重从小到大排序
        - 枚举每条边，如果两者不连通，将这条边加入到集合中（并查集）
    
    ```cpp
    int n, m;       // n是点数，m是边数
    int p[N];       // 并查集的父节点数组
    
    struct Edge     // 存储边
    {
        int a, b, w;
    
        bool operator< (const Edge &W)const
        {
            return w < W.w;
        }
    }edges[M];
    
    int find(int x)     // 并查集核心操作
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    
    int kruskal()
    {
        sort(edges, edges + m);
    
        for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集
    
        int res = 0, cnt = 0;
        for (int i = 0; i < m; i ++ )
        {
            int a = edges[i].a, b = edges[i].b, w = edges[i].w;
    
            a = find(a), b = find(b);
            if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
            {
                p[a] = b;
                res += w;
                cnt ++ ;
            }
        }
    
        if (cnt < n - 1) return INF;
        return res;
    }
    ```
    

## 3.5 二分图

概论

二分图（图中不含奇数环）

- 染色法
- 匈牙利算法
1. 染色法：用于判断一个图是否为二分图 
    - 时间复杂度
      
        时间复杂度是 O(n+m), n表示点数，m表示边数
        
    - 算法思路：DFS
      
        for(i = 0; i < n; i++)
        
        if(i 未染色）
        
        dfs(i, 1)
        
    - 实现代码：
      
        ```cpp
        int n;      // n表示点数
        int h[N], e[M], ne[M], idx;     // 邻接表存储图
        int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色
        
        // 参数：u表示当前节点，c表示当前点的颜色
        bool dfs(int u, int c)
        {
            color[u] = c;
            for (int i = h[u]; i != -1; i = ne[i])
            {
                int j = e[i];
                if (color[j] == -1)
                {
                    if (!dfs(j, !c)) return false;
                }
                else if (color[j] == c) return false;
            }
        
            return true;
        }
        
        bool check()
        {
            memset(color, -1, sizeof color);
            bool flag = true;
            for (int i = 1; i <= n; i ++ )
                if (color[i] == -1)
                    if (!dfs(i, 0))
                    {
                        flag = false;
                        break;
                    }
            return flag;
        }
        ```
    
2. 匈牙利算法
    - 时间复杂度：
      
        时间复杂度是 O(nm), n表示点数，m表示边数，但在实际运行中往往远小于O(mn)
        
    - 实现代码
      
        ```cpp
        int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
        int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
        int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
        bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过
        
        bool find(int x)
        {
            for (int i = h[x]; i != -1; i = ne[i])
            {
                int j = e[i];
                if (!st[j])
                {
                    st[j] = true;
                    if (match[j] == 0 || find(match[j]))
                    {
                        match[j] = x;
                        return true;
                    }
                }
            }
        
            return false;
        }
        
        // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
        int res = 0;
        for (int i = 1; i <= n1; i ++ )
        {
            memset(st, false, sizeof st);
            if (find(i)) res ++ ;
        }
        ```
        

# 4. 数学知识

## 4.1 质数

1. 质数的判定——试除法

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

1. 分解质因数——试除法

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

1. 筛质数
- 朴素筛法求素数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

- 线性筛法求素数

n只会被最小质因子筛掉

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

## 4.2 约数

1. 试除法求约数

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

1. 约数个数和约数之和

```cpp
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

1. 欧几里得算法

```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

## 4.3 欧拉函数

欧拉函数的定义：表示1～n中与n互质的数的个数

![截屏2022-01-12 下午5.00.06.png](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206262012674.png)

1. 根据定义求欧拉函数

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

1. 筛法求欧拉函数: 求1～N中每个数的欧拉函数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉

void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

## 4.4 快速幂

算法目的：快速计算$a^k \ mod\ p$

算法思路：

![截屏2022-01-12 下午5.05.39.png](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206262012675.png)

```cpp
// 求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

## 4.5 扩展欧几里得算法

裴蜀定理：对于任意正整数a, b，则一定存在非零整数x, y使得 $ax+by = gcd(a, b)$

算法目的：得到裴蜀定理下的(x, y)的一组解

```cpp
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

## 4.6 高斯消元

高斯消元求解多元线性方程组：
对系数矩阵进行线性变换，不影响方程的解：

- 把某一行乘一个非零数
- 交换某两行
- 把某一行的若干倍加到另一行

多元线性方程组解的情况：

- 完整阶梯形：唯一解
- 0 = 非0：无解
- 0 = 0 ：无穷多解

高斯消元步骤：

枚举每一列

- 找到当前列最大值所在的那一行
- 将这行换到最上面
- 将该行的第一个数变成1
- 将下面所有行的第c列消成0

```cpp
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}
```

## 4.7 求组合数

1. 递推法求组合数
   
    $C_a^b = C_{a-1}^b+C_{a-1}^{b-1}$ 10万组询问 1 ≤ b ≤ a ≤ 2000 对所有的$C_a^b$进行预处理
    
    ```cpp
    // c[a][b] 表示从a个苹果中选b个的方案数
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
    ```
    
2. 通过预处理逆元的方式求组合数
   
    $C_a^b = \frac{a!}{(b-a)! b!}$ 1万组询问 1 ≤ b ≤ a ≤ 100000 对所有的阶乘和其逆元进行预处理
    
    ```cpp
    首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
    如果取模的数是质数，可以用费马小定理求逆元
    int qmi(int a, int k, int p)    // 快速幂模板
    {
        int res = 1;
        while (k)
        {
            if (k & 1) res = (LL)res * a % p;
            a = (LL)a * a % p;
            k >>= 1;
        }
        return res;
    }
    
    // 预处理阶乘的余数和阶乘逆元的余数
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i ++ )
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
    ```
    
3. 利用卢卡斯定理求组合数
   
    $C_a^b 同余 C_{a\ mod\ p}^{b\ mod\ p} * C_{a/p}^{b/p} (mod\ p)$ 20万组询问 1≤ b ≤ a ≤10^18
    
    ```cpp
    若p是质数，则对于任意整数 1 <= m <= n，有：
        C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)
    
    int qmi(int a, int k, int p)  // 快速幂模板
    {
        int res = 1 % p;
        while (k)
        {
            if (k & 1) res = (LL)res * a % p;
            a = (LL)a * a % p;
            k >>= 1;
        }
        return res;
    }
    
    int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
    {
        if (a < b) return 0;
    
        LL x = 1, y = 1;  // x是分子，y是分母
        for (int i = a, j = 1; j <= b; i --, j ++ )
        {
            x = (LL)x * i % p;
            y = (LL) y * j % p;
        }
    
        return x * (LL)qmi(y, p - 2, p) % p;
    }
    
    int lucas(LL a, LL b, int p)
    {
        if (a < p && b < p) return C(a, b, p);
        return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
    }
    ```
    
4. 分解质因数法求组合数
   
    ```cpp
    当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
        1. 筛法求出范围内的所有质数
        2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
        3. 用高精度乘法将所有质因子相乘
    
    int primes[N], cnt;     // 存储所有质数
    int sum[N];     // 存储每个质数的次数
    bool st[N];     // 存储每个数是否已被筛掉
    
    void get_primes(int n)      // 线性筛法求素数
    {
        for (int i = 2; i <= n; i ++ )
        {
            if (!st[i]) primes[cnt ++ ] = i;
            for (int j = 0; primes[j] <= n / i; j ++ )
            {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }
        }
    }
    
    int get(int n, int p)       // 求n！中的次数
    {
        int res = 0;
        while (n)
        {
            res += n / p;
            n /= p;
        }
        return res;
    }
    
    vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
    {
        vector<int> c;
        int t = 0;
        for (int i = 0; i < a.size(); i ++ )
        {
            t += a[i] * b;
            c.push_back(t % 10);
            t /= 10;
        }
    
        while (t)
        {
            c.push_back(t % 10);
            t /= 10;
        }
    
        return c;
    }
    
    get_primes(a);  // 预处理范围内的所有质数
    
    for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
    {
        int p = primes[i];
        sum[i] = get(a, p) - get(b, p) - get(a - b, p);
    }
    
    vector<int> res;
    res.push_back(1);
    
    for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
        for (int j = 0; j < sum[i]; j ++ )
            res = mul(res, primes[i]);
    ```
    
5. 卡特兰数
   
    给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)
    

## 4.8 容斥原理

![截屏2022-01-19 上午10.25.06.png](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206262012676.png)

## 4.9 简单博弈论

1. NIM游戏

给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。

我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。
所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。
NIM博弈不存在平局，只有先手必胜和先手必败两种情况。

定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0

1. 公平组合游戏ICG

若一个游戏满足：

1. 由两名玩家交替行动；
2. 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；
3. 不能行动的玩家判负；
则称该游戏为一个公平组合游戏。
NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。
4. 有向图游戏

给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。

1. Mex运算

设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S

1. SG函数

在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。

1. 有向图游戏的和

设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)

1. 定理

有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。

# 5. 动态规划

## 5.1 背包问题

问题描述：现有N个物品，容量为V的背包，每个物品的体积是Vi，价值是Wi，请问背包可装物品的最大总价值是多少？

- 01背包：每个物品至多用一次
- 完全背包：每个物品可以用无限次
- 多重背包：每个物品的个数分别为Si个
- 分组背包：物品分为n组，每一组中至多选择一个物品
  
    ![截屏2022-01-20 下午1.07.32.png](https://whm-image.oss-cn-beijing.aliyuncs.com/img/202206262012677.png)
    
1. 01背包问题
   
    $f(i, j) = max(f(i-1,j),f(i-1, j-v)+w)$
    
2. 完全背包问题
   
    $f(i,j) = max(f(i-1,j),f(i, j-v_i)+w_i)$
    
    通过对状态计算公式进行简化可以得到
    
3. 多重背包问题
   
    $f(i,j)=max(f(i-1,j-v_i*k)+k*w_i)\ k=0,1, 2,...s_i$
    
    优化：二进制优化 $s_i => 1, 2,4,...2^k,c\ \ \ \ \ (s = 2^{k+1}-1+c)$，把它优化成有n*logs件物品的01背包问题
    
4. 分组背包问题
   
    $f(i,j)=max(f(i-1,j),f(i-1,j-v_{ik})+w_{ik})\ \ \ \ \ k = 1,2,...$
    

## 5.2 线性DP

<aside>
💡 线性DP是值递推有一定顺序，是比较简单的一类DP问题

</aside>

1. 数字三角形问题
- 状态表示：f(i, j)表示到第i层第j个位置总路径长度的最大值
- 状态计算：$f(i, j) = max(f(i-1,j), f(i-1, j-1)) + a[i][j]$状态划分为从左上方和右上方两个来源
1. 最长上升子序列问题
- 状态表示：f(i)表示以第i个字符结尾的最长上升子序列的长度
- 状态计算：$f(i) = f(j)+1$（a[j] < a[I] && 0 ≤ j ≤ I-1) 状态划分为前一个字符
1. 最长公共子序列问题
- 状态表示；f(i, j)表示第一个字符串前i个字符，第二个字符串前j个字符的最长公共子序列的长度
- 状态计算：$f(i, j) = max(f(i-1,j-1)+1, f(i-1,j),f(i,j-1))$划分依据是第I个字符和第j个字符是否存在于最长公共子序列中，注意划分时并非满足不重复原则

<aside>
💡 计算DP问题的时间复杂度时：复杂度 = 状态数目* 转移次数

</aside>

## 5.3 区间DP

<aside>
💡 区间DP，顾名思义，其状态定义是一个区间

</aside>

1. 石子合并问题
- 状态表示：f(i, j)表示将第i堆到第j堆石子合并所需要的代价的最小值
- 状态计算：$f(i, j)=min(f(i,k),f(k+1,j)+s[j] - s[i-1]$状态划分是按照最后一次合并的位置

<aside>
💡 区间DP问题要注意枚举的顺序，常常采用的枚举顺序是先枚举区间长度，然后再枚举区间的左端点

</aside>

## 5.4 计数类DP

<aside>
💡 数位DP的关键在于分情况讨论

</aside>

好难～以后再写

## 5.5 状态压缩DP

<aside>
💡 状态压缩顾名思义是指把状态用一个二进制数来表示

</aside>

1. 蒙德里安的梦想
- 状态表示：f(i, j)表示第i列，j存放的是上一列伸出的小方块的标号，所有满足j & k == 0 而且j | k 不存在连续奇数个0的状态个数
- 状态计算：$f(i,j) = sum(f(i-1,k))$状态划分是按照上一列的方块摆放状态
1. 最短Hamilton路径
- 状态表示：f(i, j)表示所有从0走到j节点，i表示所有节点的状态（是否走过）
- 状态计算：$f(i,j) =min(f(i-\{j\},k)+a(k,j))$状态划分是倒数第二个节点

## 5.6 树形DP

<aside>
💡 树形DP顾名思义是有关树形结构的DP问题

</aside>

1. 没有上司的舞会
- 状态表示：f(u,0)表示以u为为根的子树中选择并且不包含u的最大值；f(u. 1)表示以u为根的子树中选择并且包含u的最大值
- 状态计算：$f(u,0) = \sum max(f(s_i,0),f(s_i,1)) f(u,1)=\sum f(s_i,0)$

## 5.7 记忆化搜索

> 记忆化搜索本质上就是递归的方法写DP，其优点是代码复杂度比较低，往往需要将所有待搜索的节点初始化为-1

1. 滑雪
- 状态表示：f(i, j)表示从i，j这个节点开始能够滑的最大距离
- 状态计算：$f(i,j) = max(f(i-1,j),f(i+1,j),f(i,j-1),f(i,j+1) i,j均满足一定条件$